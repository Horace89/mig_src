/*
	 MiG Alley
	 Copyright (C) 1998, 1999, 2000, 2001 Empire Interactive (Europe) Ltd,
	 677 High Road, North Finchley, London N12 0DA

	 Please see the document licence.doc for the full licence agreement

2. LICENCE
 2.1 	
 	Subject to the provisions of this Agreement we now grant to you the 
 	following rights in respect of the Source Code:
  2.1.1 
  	the non-exclusive right to Exploit  the Source Code and Executable 
  	Code on any medium; and 
  2.1.2 
  	the non-exclusive right to create and distribute Derivative Works.
 2.2 	
 	Subject to the provisions of this Agreement we now grant you the
	following rights in respect of the Object Code:
  2.2.1 
	the non-exclusive right to Exploit the Object Code on the same
	terms and conditions set out in clause 3, provided that any
	distribution is done so on the terms of this Agreement and is
	accompanied by the Source Code and Executable Code (as
	applicable).

3. GENERAL OBLIGATIONS
 3.1 
 	In consideration of the licence granted in clause 2.1 you now agree:
  3.1.1 
	that when you distribute the Source Code or Executable Code or
	any Derivative Works to Recipients you will also include the
	terms of this Agreement;
  3.1.2 
	that when you make the Source Code, Executable Code or any
	Derivative Works ("Materials") available to download, you will
	ensure that Recipients must accept the terms of this Agreement
	before being allowed to download such Materials;
  3.1.3 
	that by Exploiting the Source Code or Executable Code you may
	not impose any further restrictions on a Recipient's subsequent
	Exploitation of the Source Code or Executable Code other than
	those contained in the terms and conditions of this Agreement;
  3.1.4 
	not (and not to allow any third party) to profit or make any
	charge for the Source Code, or Executable Code, any
	Exploitation of the Source Code or Executable Code, or for any
	Derivative Works;
  3.1.5 
	not to place any restrictions on the operability of the Source 
	Code;
  3.1.6 
	to attach prominent notices to any Derivative Works stating
	that you have changed the Source Code or Executable Code and to
	include the details anddate of such change; and
  3.1.7 
  	not to Exploit the Source Code or Executable Code otherwise than
	as expressly permitted by  this Agreement.

questions about this file may be asked at http://www.simhq.com/
*/

//------------------------------------------------------------------------------
//Filename       comms.cpp
//System         
//Author         Andrew McRae
//Date           Mon 23 Sep 1996
//Description    All Comms Init Stuff Prior to Sending Init Packets
//------------------------------------------------------------------------------

#define INITGUID
#define	F_COMMON
#define IDIRECTPLAY2_OR_GREATER
#include	"DOSDefs.H"
#include	<stdio.h>
#include	<stdlib.h>

#include 	<windows.h>
#include	"dplay.h"
#include	"dplobby.h"

#include	"WinMain.H"

#include	"myerror.h"

#include	"worldinc.h"
#include	"uniqueID.h"
#include	"files.g"
#include	"text.h"
#include	"3dinstr.h"
#include	"savegame.h"
#include	"winmove.h"


#include	"misssub.h"
#include	"comms.h"

#include	"cbuffer.h"
#include	"aggrgtor.h"
#include	"missman2.h"
#include	"Mytime.h"
#include	"globrefs.h"
#include	"stub3d.h"
#include	"ctimeout.h"
#include	"..\mfc\resource.h"
#include	"replay.h"
#include	"bstream.h"
#include	"rchatter.h"
#include	"persons2.h"
#include	"overlay.h"
#include	"miles.h"

//#include	"persons2.h"
//#include	"ui.h"

//#define TEMPTIMEOUT 3000
//#define CTRACE

//STATICS!!!

H2HPlayerInfo DPlay::H2H_Player[MAXPLAYERS];

DPlay _DPlay;

//NOTE: the following GUID was generated by guidgen.exe

// {38305683-01EB-11d2-B1A4-004005247C2D}

// for lobbied games the GUID defined here is not used, the registry entry is instead
// used to find games. This must be altered by the install program.

#ifndef	MIG_DEMO_VER
DEFINE_GUID(MIGALLEY_GUID, 
//DEADCODE DAW 08/02/00 0x38305683, 0x1eb, 0x11d2, 0xb1, 0xa4, 0x0, 0x40, 0x5, 0x24, 0x7c, 0x3d);
0x38305683, 0x1eb, 0x11d2, 0xb1, 0xa4, 0x0, 0x40, 0x5, 0x24, 0x7c, 0x6d);
#else
//DEADCODE DAW 07/02/00 DEFINE_GUID(MIGALLEY_GUID, 
//DEADCODE DAW 07/02/00 0x38305683, 0x1eb, 0x11d2, 0xb1, 0xa4, 0x0, 0x40, 0x5, 0x24, 0x7c, 0x4d);
DEFINE_GUID(MIGALLEY_GUID, 
0x38305683, 0x1eb, 0x11d2, 0xb1, 0xa4, 0x0, 0x40, 0x5, 0x24, 0x7c, 0x5d);
#endif 

// Callback Functions	

BOOL WINAPI	EnumConnectionsCallback(LPCGUID lpguidSP, LPVOID lpConnection, DWORD dwConnectionSize,
									LPCDPNAME lpName, DWORD dwFlags, LPVOID pContext);

BOOL WINAPI EnumSessionsCallback(LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeOut,
								DWORD dwFlags, LPVOID lpContext);

BOOL WINAPI EnumSessionsDataCallback(LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeOut,
								DWORD dwFlags, LPVOID lpContext);

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ExitDirectPlay
//Author		Andrew McRae
//Date			Fri 9 Aug 1996
//
//Description	exits DirectPlay Nice & Clean
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::ExitDirectPlay ()
{
	PlayerCreated = FALSE;
	Implemented = FALSE;
	singlesession=false;
	SideSelected=false;
	Host=FALSE;
	csync=false;												//DAW 22Jun99

	delete [] CommsPacketPtr;
	CommsPacketPtr=NULL;
	CommsPacketLength=0;

	lpAppGuid=NULL;

	if (lpDP4)
	{
		lpDP4->Close();
		lpDP4->Release();
		lpDP4=NULL;
	}

	DeleteAIACPositionsList();

	DeleteSessionList();

	DeleteServiceList();

	DeleteLobbyInfo();
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UIMultiPlayInit
//Author		Andy McMaster
//Date			Thu 27 Nov 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::UIMultiPlayInit ()
{
	Lobbied=FALSE;

	if (!CreateDPlayInterface())
		return FALSE;

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UISelectServiceProvider
//Author		Andy McMaster
//Date			Wed 9 Jul 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::UISelectServiceProvider(char* servicename)
{
	HRESULT res=DPERR_INVALIDPARAMS;
	LPENUMSERVICE temp;

	temp=ServiceList;

	while (temp)
	{
		if (!strcmp(servicename,temp->sname))
		{
			res=lpDP4->InitializeConnection(temp->connection,0);

			if (res==DP_OK)
			{
//DeadCode AMM 23Mar99 				if (temp->sid==DPSPGUID_MODEM
//DeadCode AMM 23Mar99 				||  temp->sid==DPSPGUID_TCPIP
//DeadCode AMM 23Mar99 				||  temp->sid==DPSPGUID_SERIAL)
//DeadCode AMM 23Mar99 				{
//DeadCode AMM 23Mar99 					singlesession=true;
//DeadCode AMM 23Mar99 				}
				if (temp->sid==DPSPGUID_MODEM)
				{
// special setup code for modem

					network=false;
//DeadCode RDH 11Jul99 					RateDivider=2;
					RateDivider=4;
					CommsTimeoutLength=20000;
					singlesession=false;
//DeadCode RDH 11Jul99 					singlesession=true;
				}
				else if (temp->sid==DPSPGUID_TCPIP)
				{
// special setup code for internet

					network=false;
					RateDivider=4;
					CommsTimeoutLength=20000;
					singlesession=false;
//					singlesession=true;
				}
				else if (temp->sid==DPSPGUID_SERIAL)
				{
// special setup code for serial

//					RateDivider=2;
					network=false;
					RateDivider=3;
					CommsTimeoutLength=10000;
					singlesession=true;
				}
				else if (temp->sid==DPSPGUID_IPX)
				{
// special setup code for network

					network=true;
					RateDivider=2;
					CommsTimeoutLength=10000;
					singlesession=false;
				}
				else
				{
// others - treat as internet

					network=false;
					RateDivider=4;
					CommsTimeoutLength=20000;
					singlesession=false;
				}
			}
			break;
		}
		temp=temp->Next;
	}

	if (res!=DP_OK)										
		return FALSE;

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UIGetSessionListUpdate
//Author		Andrew McRae
//Date			Tue 24 Sep 1996
//
//Description	Obtain and insert into list all sessions
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool DPlay::UIGetSessionListUpdate ()
{
	ULong n;
	char** Name;
	HRESULT res=DP_OK;												  //JIM 29/03/99
	DPSESSIONDESC2 DPSessionDesc2;

	DeleteSessionList();

	memset( &DPSessionDesc2, 0x00, sizeof(DPSESSIONDESC2));

	DPSessionDesc2.dwSize = sizeof (DPSESSIONDESC2);
 	DPSessionDesc2.guidApplication=*lpAppGuid;					

	if (lpDP4)
		res = lpDP4->EnumSessions (
			(LPDPSESSIONDESC2)&DPSessionDesc2,
			(DWORD)0,
			EnumSessionsCallback,
			(LPVOID)NULL,
			(DWORD)(DPENUMSESSIONS_AVAILABLE|DPENUMSESSIONS_ASYNC)
			);

	if (res!=DP_OK) 
	{
		return false;
	}

	return true;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UIAssignServices
//Author		Andy McMaster
//Date			Fri 18 Jul 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::UIAssignServices()
{
	HRESULT res;
	LPENUMSERVICE temp;
	char** Service;
	ULong size1=0,size2=0,n;

	DeleteServiceList();

//DeadCode AMM 12Oct98 // add connection to Empire Lobby
//DeadCode AMM 12Oct98 
//DeadCode AMM 12Oct98 	temp=ServiceList;
//DeadCode AMM 12Oct98 	LPENUMSERVICE nextservice=new ENUMSERVICE;
//DeadCode AMM 12Oct98 
//DeadCode AMM 12Oct98 	nextservice->Next=NULL;
//DeadCode AMM 12Oct98 	nextservice->sname=new char[20];
//DeadCode AMM 12Oct98 	strcpy(nextservice->sname,"Empire Lobby");
//DeadCode AMM 12Oct98 	nextservice->sid=NULL;
//DeadCode AMM 12Oct98 	nextservice->connection=NULL;
//DeadCode AMM 12Oct98 
//DeadCode AMM 12Oct98 	if (ServiceList==NULL)
//DeadCode AMM 12Oct98 	{
//DeadCode AMM 12Oct98 		ServiceList=nextservice;
//DeadCode AMM 12Oct98 	}
//DeadCode AMM 12Oct98 	else
//DeadCode AMM 12Oct98 	{
//DeadCode AMM 12Oct98 		while (temp->Next)
//DeadCode AMM 12Oct98 			temp=temp->Next;
//DeadCode AMM 12Oct98 
//DeadCode AMM 12Oct98 		temp->Next=nextservice;
//DeadCode AMM 12Oct98 	}
//DeadCode AMM 12Oct98 
//DeadCode AMM 12Oct98 	nextservice=NULL;

	res=lpDP4->EnumConnections(lpAppGuid,EnumConnectionsCallback,NULL,0);
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UINewPlayer
//Author		Andrew McRae
//Date			Mon 23 Sep 1996
//
//Description	Create a new player - from enter name in UI
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::UINewPlayer (char* Name, char* SessionName)
{
	HRESULT res;
	ULong t;
	DPSESSIONDESC2 DPSessionDesc2;

// check if name is null - if so abort

	if (!strlen(Name))
		return FALSE;

	if (ServedGame)
	{
		if (!ConnectToAggregator(aggID,Name))
			return FALSE;

		return TRUE;
	}

	if (UIPlayerType==PLAYER_HOST)
	{
// fill out dpsessiondesc2 struc

		memset(&DPSessionDesc2, 0x00, sizeof(DPSESSIONDESC2));

		DPSessionDesc2.dwSize = sizeof (DPSESSIONDESC2);
		DPSessionDesc2.dwMaxPlayers = MAXPLAYERS+1;	 // allow for aggregator
		DPSessionDesc2.guidApplication=*lpAppGuid;				
		DPSessionDesc2.dwCurrentPlayers=0;

		DPSessionDesc2.lpszSessionNameA=new char[PLAYERNAMELEN];
		strcpy( DPSessionDesc2.lpszSessionNameA, _DPlay.SessionName);
		
		
// create session

		DPSessionDesc2.dwFlags|=DPSESSION_DIRECTPLAYPROTOCOL	// need asyncronous send
								|DPSESSION_KEEPALIVE			// keep track of player falling out
								| DPSESSION_OPTIMIZELATENCY; // no nagling
								
		res=lpDP4->Open(&DPSessionDesc2,DPOPEN_CREATE);

		delete [] DPSessionDesc2.lpszSessionNameA;

		if (res!=DP_OK)
			return FALSE;

// myPlayerID is the Host in the session

		Host = TRUE;
		AllowJoins=TRUE;								
	}
	else if (UIPlayerType==PLAYER_GUEST)
	{
// check if session name is null - if so abort

		if (!strlen(SessionName))
			return FALSE;
	
// Connect to an existing Session

		memset( &DPSessionDesc2, 0x00, sizeof(DPSESSIONDESC2));

		DPSessionDesc2.dwSize = sizeof (DPSESSIONDESC2);

		DPSessionDesc2.guidApplication = *lpAppGuid;
		DPSessionDesc2.lpszSessionNameA=new char[PLAYERNAMELEN];
		strcpy( DPSessionDesc2.lpszSessionNameA, _DPlay.SessionName);
		
// get session data

		res = lpDP4->EnumSessions (
			(LPDPSESSIONDESC2)&DPSessionDesc2,
			(DWORD)0,
			EnumSessionsDataCallback,
			(LPVOID)SessionName,
			(DWORD)(DPENUMSESSIONS_AVAILABLE|DPENUMSESSIONS_ASYNC)
			);

		delete [] DPSessionDesc2.lpszSessionNameA;

		if (tempdpsessdesc2!=NULL)
		{
			memcpy(&DPSessionDesc2,tempdpsessdesc2,sizeof(DPSESSIONDESC2));
			delete [] tempdpsessdesc2;
			tempdpsessdesc2=NULL;
		}

		if (res!=DP_OK)
			return FALSE;

		res=lpDP4->Open ( &DPSessionDesc2,DPOPEN_JOIN );

		if (res!=DP_OK)
			return FALSE;

		Host = FALSE;

//DeadCode DAW 01Jun99 		_Replay.BackupPrefs();
	}
	else
		return FALSE;

// Create a player

	if (!SetUpPlayer())
		return FALSE;

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		UIUpdateMainSheet
//Author		Andrew McRae
//Date			Wed 25 Sep 1996
//
//Description	Update Main Sheet with player details
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::UIUpdateMainSheet ()
{
//DeadCode AMM 12May99 	char RecPacket[MAXCOMMSPACKETSIZE];
	char* RecPacket;
//DeadCode AMM 12May99 	ULong RecPacketLen=MAXCOMMSPACKETSIZE;
	ULong RecPacketLen=0;
	ULong n,m,from;
	Bool	stop=TRUE;
	Bool	retval;

// if we are on way out then dont bother to do anything (especially process messages - ohno..)

	if (LeaveCommsFlag)
		return;

// make sure status is not 3D!									

	Implemented=FALSE;

	ResendTime--;

	if (!Host && !ResendTime)
	{
		IsGameAvailable();
		ResendTime=20;
	}

// if we are ready to go then dont receive any messages here, wait till
// selectfly !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	if (FlyNowFlag)
		return;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if ((H2H_Player+n)->status==CPS_3D)
			stop=FALSE;
	}

	if (stop && !SentStopResetMess)
	{
		SentStopResetMess=TRUE;
		GameRunning=FALSE;
	}

	ULong to=myDPlayID;
//DeadCode AMM 12May99 	while (ReceiveNextMessage(RecPacket,RecPacketLen,from))
	while (ReceiveNextMessage(RecPacket,RecPacketLen,from,to,DPRECEIVE_TOPLAYER))
	{
		if (from==0)
			retval=ProcessSystemMessage(RecPacket,H2H_Player[mySlot].status);
		else
		{
// if aggregated packet ignore 

			if (from!=aggID)
			{
				retval=ProcessPlayerMessage(RecPacket,RecPacketLen,from,(H2H_Player+mySlot)->status);
				if (!retval) 
					break;
			}
		}
//DeadCode AMM 12May99 		RecPacketLen = MAXCOMMSPACKETSIZE;
	}

	if (!MainSheetCount) 
	{
// First time in

		InitMainSheetInfo();
		MainSheetCount=TRUE;

		for (n=0;n<MAXPLAYERS;n++)
			SyncPacks[n]=0;
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UILeavingMainSheet
//Author		Andrew McRae
//Date			Wed 25 Sep 1996
//
//Description	Player leaves main Sheet
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::UILeavingMainSheet ()
{
	if (PlayerCreated)
	{
// Send Player leaving packet

		COMMONDATA data;

		data.PacketID=PID_PLAYERQUIT;
		data.PlayerID=myDPlayID;

		SendMessageToAll ((char*)&data,sizeof(COMMONDATA));

		MyTeamKills=0;
		MyTeamDeaths=0;
		EnemyTeamKills=0;
		EnemyTeamDeaths=0;

		if (!Host)
			_Replay.RestorePrefs();
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UIPaintShop
//Author		Andrew McRae
//Date			Wed 25 Sep 1996
//
//Description	Toggle Paintshop flag to say if player is in Paintshop
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::UISendInPaintShopMessage ()
{
	COMMONDATA pack;

// Send PID_INPAINTSHOP

	pack.PacketID = PID_INPAINTSHOP;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendInVisitorsBookMessage
//Author		Andy McMaster
//Date			Mon 14 Dec 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SendInVisitorsBookMessage()
{
	COMMONDATA pack;

	pack.PacketID = PID_INVISITORS;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendInDebriefMessage
//Author		Andy McMaster
//Date			Wed 16 Dec 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SendInDebriefMessage()
{
	COMMONDATA pack;

	pack.PacketID = PID_INDEBRIEF;

	H2H_Player[mySlot].status=CPS_DEBRIEF;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UIPrefs
//Author		Andrew McRae
//Date			Wed 25 Sep 1996
//
//Description	Toggle Prefs flag to say if player is in Prefs
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::UISendInPrefsMessage ()
{
	COMMONDATA pack;

	pack.PacketID=PID_INPREFS;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UISendPrefs
//Author		Andrew McRae
//Date			Fri 4 Oct 1996
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::UISendPrefs (bool request) //Bool Final) //SaveData* Save_Data, SWord currmission_no, SLong missiontime, Bool Final)
{
	UIPREFSDATA UIPrefsData;

// Only send prefs if I am the host

	if (PlayerCreated && Host)
	{
		UIPrefsData.PacketID = PID_PREFSDATA;

		UIPrefsData.PlayerID = myDPlayID;

		Save_Data.gamedifficulty|=GD_VULNERABLE;
		Save_Data.gamedifficulty|=GD_GROUNDCOLLISIONS;			
		Save_Data.gamedifficulty|=GD_COLLISIONS;			
		Save_Data.flightdifficulty%=FD_AUTOTHROTTLE;			

		UIPrefsData.flightdifficulty	=	Save_Data.flightdifficulty;
		UIPrefsData.gamedifficulty		=	Save_Data.gamedifficulty;
		UIPrefsData.targetsize			=	Save_Data.targetsize;
		UIPrefsData.autopilotskillUN	= 	Save_Data.autopilotskillUN;
		UIPrefsData.autopilotskillRED	= 	Save_Data.autopilotskillRED;

//DeadCode AMM 08Apr99 		UIPrefsData.DataRate=RateDivider;

//DeadCode AMM 23May99 		return(SendMessageToPlayers ((char*)&UIPrefsData, sizeof(UIPREFSDATA)));
//DeadCode AMM 16Jun99 		if (H2H_Player[mySlot].status==CPS_3D)
		if (!request)
		{
			if (SendGMessageToPlayersTimeout ((char*)&UIPrefsData, sizeof(UIPREFSDATA)))
				return TRUE;
		}
		else
		{
			if (SendMessageToPlayers((char*)&UIPrefsData,sizeof(UIPREFSDATA)))
				return TRUE;
//DeadCode AMM 16Jun99 			SendMessageToPlayers((char*)&UIPrefsData,sizeof(UIPREFSDATA));
		}
	}
	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UISendDialogue
//Author		Andrew McRae
//Date			Fri 27 Sep 1996
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//void DPlay::UISendDialogue (H2HPlayerInfo* H2H_Player, char* Text)
void DPlay::UISendDialogue (const char* Text)
{
	UIPLAYERDATA UIPlayerData;
	ULong UIPlayerSize;

// truncate text to 100 chars

	strncpy( &((H2H_Player+mySlot)->dialogue[0]),Text,99);
	H2H_Player[mySlot].dialogue[99]='\0';

	CopyBuffer((char*)(&UIPlayerData.playerinfo),(char*)(H2H_Player+mySlot),sizeof(H2HPlayerInfo));

// nobble playerid for use as send to all/my team switch

	UIPlayerData.PlayerID=sendtowho;

	UIPlayerData.PacketID = PID_MESSAGE;

	UIPlayerSize = sizeof (UIPLAYERDATA);

	SendMessageToPlayers ((char*)&UIPlayerData, UIPlayerSize);
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UINetworkSelectFly
//Author		Andrew McRae
//Date			Mon 23 Sep 1996
//
//Description	Network Fly Selection
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::UINetworkSelectFly ()
{
	HRESULT res;
	UIPLAYERDATA UIPlayerData;
	ULong UIPlayerSize;
//DeadCode AMM 12May99 	char RecPacket[MAXCOMMSPACKETSIZE];
	char* RecPacket;
	ULong RecPacketLen,From;
	H2HPlayerInfo* thisH2H_Player;
	ULong	n;

#ifdef CTRACE
	FILE* fp=fopen("ctrace.txt","at");
	fprintf(fp,"UINetworkSelectFly\n");
	fprintf(fp,"==================\n");
#endif

	CountPlayers();												//DAW 27Jun99
																//DAW 27Jun99
	if (Host)													//DAW 27Jun99
	{															//DAW 27Jun99
		if (GameType>TEAMPLAY)									//DAW 27Jun99
		{														//DAW 27Jun99
			if (!AllPlayersHaveSlots())							//DAW 27Jun99
			{													//DAW 27Jun99
				CommsMessage(IDS_NOTSLOTS);						//DAW 27Jun99
				EnableJoins();									//DAW 27Jun99
				return FALSE;									//DAW 27Jun99
			}													//DAW 27Jun99
		}														//DAW 27Jun99
		else													//DAW 27Jun99
		{														//DAW 27Jun99
			for (n=0;n<MAXPLAYERS;n++)							//DAW 27Jun99
			{													//DAW 27Jun99
				if (H2H_Player[n].status!=CPS_NONE && H2H_Player[n].status!=CPS_READYROOM)//DAW 27Jun99
					return FALSE;								//DAW 27Jun99
			}													//DAW 27Jun99
		}														//DAW 27Jun99
	}															//DAW 27Jun99

//	for (n=0;n<MAXPLAYERS;n++)
//		SyncPacks[n]=0;

//	SyncBits=0;

// need this at beginning so that when I send my playerinfo packet the status is set up OK
// otherwise I will send a READYROOM status that may be processed after 3D status us set up
// resulting in EMPTY shapes in game


// all dudes are in 3d

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].status!=CPS_NONE)
		{
			H2H_Player[n].status=CPS_3D;
		}
	}

	if (!PlayerCreated)
	{
#ifdef CTRACE
		fprintf(fp,"PlayerNotCreated\n");
		fclose(fp);
#endif
		return FALSE;
	}

	DisableJoins();

	AllowJoins=FALSE;
	Joining=FALSE;
	JustJoined=FALSE;
	SimulateExitKey=FALSE;

//DeadCode DAW 27Jun99 	CountPlayers();

	ResetAllocPacket();

	if (GameType<COMMSCAMPAIGN)
		ClearPackages();

//DeadCode DAW 27Jun99 	if (GameType>TEAMPLAY && Host)
//DeadCode DAW 27Jun99 	{
//DeadCode DAW 27Jun99 		if (!AllPlayersHaveSlots())
//DeadCode DAW 27Jun99 		{
//DeadCode DAW 27Jun99 			CommsMessage(IDS_NOTSLOTS);
//DeadCode DAW 27Jun99 			EnableJoins();
//DeadCode DAW 27Jun99 			return FALSE;
//DeadCode DAW 27Jun99 		}
//DeadCode DAW 27Jun99 	}

	if (Host)
	{
		if (!UISendFlyNow())
 		{
#ifdef CTRACE
			fprintf(fp,"SendFlyNow message failed\n");
			fclose(fp);
#endif
			EnableJoins();
			return FALSE;
		}
	}
#ifdef CTRACE
		fprintf(fp,"begin info collection\n");
		fflush(fp);
#endif

	csync=false;
//DeadCode AMM 13May99 	Implemented = TRUE;

	if (!UpdateMessages())
	{
#ifdef CTRACE
		fprintf(fp,"updatemessages FAILED\n");
		fclose(fp);
#endif
		EnableJoins();
		return FALSE;
	}

// get all players h2h_player info

	if (!UpdatePlayerInfo())
	{
#ifdef CTRACE
		fprintf(fp,"udpateplayerinfo FAILED\n");
		fclose(fp);
#endif
		EnableJoins();
		return FALSE;
	}

// PREFS UPDATE

	if (!UIUpdatePrefs())
	{
#ifdef CTRACE
		fprintf(fp,"updateprefs FAILED\n");
		fclose(fp);
#endif
		EnableJoins();
		return FALSE;
	}

	if (GameType<COMMSQUICKMISSION)
	{
		if (!UpdateMissionConditions())
		{
#ifdef CTRACE
			fprintf(fp,"updatemissionconds FAILED\n");
			fclose(fp);
#endif
			EnableJoins();
			return FALSE;
		}
	}

	if (GameType==COMMSCAMPAIGN)
	{
//DeadCode AMM 12May99 		if (Host)
//DeadCode AMM 12May99 			SendSaveGame();
//DeadCode AMM 12May99 		else
//DeadCode AMM 12May99 			ReceiveStartupSaveGame(false);
		if (Host)
		{
			if (!SendSaveGame(false,false))
			{
				EnableJoins();
				return FALSE;
			}
		}
		else
		{
			if (!ReceiveStartupSaveGame(false))
			{
				EnableJoins();
				return FALSE;
			}
		}
	}
	else if (GameType==COMMSQUICKMISSION)
	{
		if (Host)
		{
			if (!SendCampaignStruc(false))
			{
				EnableJoins();
				return FALSE;
			}
		}
		else
		{
			if (!ReceiveCampaignStruc())
			{
				EnableJoins();
				return FALSE;
			}
		}
	}

#ifdef CTRACE
	fclose(fp);
#endif

	ULong	squads[SQ_R_NONFLYABLE+1];		   //include Yak

	if (GameType<COMMSQUICKMISSION)
	{
		FillCSQuickStruc();

// position 

		for (n=0;n<=SQ_R_NONFLYABLE;n++)
		{
			squads[n]=0;
		}

		for (n=0;n<MAXPLAYERS;n++)
		{
			H2H_Player[n].position=squads[H2H_Player[n].squadron];
			squads[H2H_Player[n].squadron]++;
		}
	}

	MMC.playersquadron=H2H_Player[mySlot].squadron;
	MMC.playeracnum=H2H_Player[mySlot].position;

//DeadCode DAW 01Jun99 // all dudes are in 3d
//DeadCode DAW 01Jun99 
//DeadCode DAW 01Jun99 	for (n=0;n<MAXPLAYERS;n++)
//DeadCode DAW 01Jun99 	{
//DeadCode DAW 01Jun99 		if (H2H_Player[n].status!=CPS_NONE)
//DeadCode DAW 01Jun99 		{
//DeadCode DAW 01Jun99 			H2H_Player[n].status=CPS_3D;
//DeadCode DAW 01Jun99 		}
//DeadCode DAW 01Jun99 	}

	GR_amberstrength = MAXPLAYERS;

//	Save_Data->vol.music = 0;									

//DeadCode AMM 06Jun99 	GameRunning=TRUE;
//DeadCode AMM 06Jun99 	deadplayers=0;
//DeadCode AMM 06Jun99 	accelselected=0;
//DeadCode AMM 06Jun99 	Implemented = TRUE;											//AMM 13May99

//DeadCode AMM 06Jun99 // reset all flags etc before launching 3d as inital sync is on interrupt and can get
//DeadCode AMM 06Jun99 // called before flags are setup in SendInit and SendInit2 etc
//DeadCode AMM 06Jun99 
//DeadCode AMM 06Jun99 	firsttimein = TRUE; //AMM 18/05/99
//DeadCode AMM 06Jun99 	synched=FALSE; //AMM 18/05/99
//DeadCode AMM 06Jun99 	csync=false; //AMM 18/05/99
//DeadCode AMM 06Jun99 	ResyncPhase=FALSE; //AMM 18/05/99
//DeadCode AMM 06Jun99 	Initiator=FALSE; //AMM 18/05/99
//DeadCode AMM 06Jun99 	realfirsttimein=TRUE; //AMM 18/05/99
//DeadCode AMM 06Jun99 	resyncsgot=0; //AMM 18/05/99
//DeadCode AMM 06Jun99 	SimulateExitKey=FALSE; //AMM 18/05/99
//DeadCode AMM 06Jun99 	InitSyncData(true); //AMM 18/05/99
//DeadCode AMM 06Jun99 	FrameCount = 0; //AMM 18/05/99
//DeadCode AMM 06Jun99 	ResetSync=true; //AMM 18/05/99
//DeadCode AMM 06Jun99 	beginsyncflag=false;
//DeadCode AMM 06Jun99 	resetreceivesync=false;

	InitialFlagReset();

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendMessageToAll
//Author		Andrew McRae
//Date			Thu 26 Sep 1996
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 15Apr99 Bool DPlay::SendMessageToAll (char* Data, ULong Length)
Bool DPlay::SendMessageToAll (void* Data, ULong Length)
{
	return (SendMessage(Data,Length,DPID_ALLPLAYERS));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendMessageToPlayers
//Author		Andy McMaster
//Date			Fri 1 May 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 15Apr99 Bool DPlay::SendMessageToPlayers (char* Data, ULong Length)
Bool DPlay::SendMessageToPlayers (void* Data, ULong Length)
{
	return (SendMessage(Data,Length,playergroupID));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendMessage
//Author		Andy McMaster
//Date			Tue 25 Aug 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 15Apr99 Bool DPlay::SendMessage(char* data, ULong len, ULong to)
Bool DPlay::SendMessage(void* data, ULong len, ULong to)
{
	HRESULT res;
	res=lpDP4->SendEx (myDPlayID,to,DPSEND_ASYNC|DPSEND_NOSENDCOMPLETEMSG,data,len,0,0,NULL,NULL);
				
	if (res==DP_OK || res==DPERR_PENDING)
		return TRUE;

	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendGMessageToPlayers
//Author		Andy McMaster
//Date			Tue 16 Mar 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	DPlay::SendGMessageToPlayers(char* data, ULong len)
{
	if (SendGMessageToPlayersTimeout(data,len))
		return true;

	return false;

/*	HRESULT res;

//	res=lpDP4->SendEx (myDPlayID,playergroupID,DPSEND_ASYNC|DPSEND_NOSENDCOMPLETEMSG,data,len,0,0,NULL,NULL);
	res=lpDP4->SendEx (myDPlayID,playergroupID,DPSEND_GUARANTEED,data,len,0,0,NULL,NULL);

	if (res==DP_OK || res==DPERR_PENDING)
		return true;

	return false;*/
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendGMessageToPlayersTimeout
//Author		Andy McMaster
//Date			Sun 23 May 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	DPlay::SendGMessageToPlayersTimeout(char* data, ULong len)
{
	HRESULT res=DPERR_SENDTOOBIG;
	ULong now=_Miles.GetSysTime();
	CommsTimeout time(now,CommsTimeoutLength);

	while (res!=DP_OK && res!=DPERR_PENDING)
	{
		now=_Miles.GetSysTime();
		if (time.TimedOut(now)) 
		{
			return false;
		}

		if (!network)
		{
			res=lpDP4->SendEx (myDPlayID,playergroupID,DPSEND_ASYNC|DPSEND_NOSENDCOMPLETEMSG,data,len,0,0,NULL,NULL);
		}
		else
		{
			res=lpDP4->SendEx (myDPlayID,playergroupID,DPSEND_GUARANTEED,data,len,0,0,NULL,NULL);
		}
//		res=lpDP4->SendEx (myDPlayID,playergroupID,DPSEND_ASYNC|DPSEND_NOSENDCOMPLETEMSG,data,len,0,0,NULL,NULL);
	}

	return true;
}
//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		GetMySlot
//Author		Andy McMaster
//Date			Mon 10 Feb 1997
//
//Description	Requests host for a game id. Wait until one is received.
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::GetMySlot()
{
	COMMONDATA pack;
	myDPID From=myDPlayID;

	pack.PlayerID=myDPlayID;
	pack.PacketID=PID_REQUESTSLOT;

// send request for id, timeout on send - session could have ended

	SendMessageToAll((char*)&pack,sizeof(COMMONDATA));

// wait for response 

	myDPID To=myDPlayID;
	From=0;
//DeadCode AMM 12May99 	char	Buffer[MAXCOMMSPACKETSIZE];
	char* Buffer;
//DeadCode AMM 12May99 	ULong	BufferLen=MAXCOMMSPACKETSIZE;
	ULong	BufferLen=0;
	Bool	GotID=FALSE;
// NEEDTIMEOUT
	ULong now=_Miles.GetSysTime();

	CommsTimeout time(now,CommsTimeoutLength); // example!

	while(!GotID)
	{
		now=_Miles.GetSysTime();
		if (time.TimedOut(now)) // example!
			return FALSE;

//DeadCode AMM 12May99 		BufferLen=MAXCOMMSPACKETSIZE;
			
		ULong to=myDPlayID;
//DeadCode AMM 12May99 		if (ReceiveNextMessage(Buffer,BufferLen,From))
		if (ReceiveNextMessage(Buffer,BufferLen,From,to,DPRECEIVE_TOPLAYER))
		{
			if (BufferLen==sizeof(COMMONDATA))
			{
				pack=*(PCOMMONDATA)Buffer;

				if(pack.PacketID==PID_NEWSLOT)
				{
					mySlot=pack.Slot;
					GotID=TRUE;
					aggID=From;
					playergroupID=pack.PlayerID;
				}
			}
		}
	}

// send "I'm in with this slot" message

	pack.PacketID=PID_IMHERE;
	pack.PlayerID=mySlot;

	SendMessageToAll((char*)&pack,sizeof(COMMONDATA));

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendSlot
//Author		Andy McMaster
//Date			Mon 10 Feb 1997
//
//Description	Sends a packet in which game ID is for the receiving player,
//				not the id of the sender. If error occurs, I dont care,
//				player is not in game	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::SendSlot(myDPID playerid, ULong slot)
{
	COMMONDATA	packet;
	ULong From=aggID; //,t=0;
	HRESULT res=DPERR_NOMESSAGES;

	packet.PlayerID=playergroupID;
	packet.Slot=slot;
	packet.PacketID=PID_NEWSLOT;

	res=lpDP4->SendEx(From,playerid,DPSEND_ASYNC|DPSEND_NOSENDCOMPLETEMSG,(char*)&packet,sizeof(COMMONDATA),0,0,NULL,NULL);

	if (res==DP_OK || res==DPERR_PENDING)
		return TRUE;

	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		AddStatusBar
//Author		Andy McMaster
//
//Description	Draws a bar on physical scren representing amount of time
//				left to 3d and where each player is up to in initial bout
//				of data transfers. Any slow players should be noticeable...
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 16Jun99 void DPlay::AddStatusBar(Bool reset,ULong playerid)
//DeadCode AMM 16Jun99 {
//DeadCode AMM 16Jun99 }

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DeleteServiceList
//Author		Andy McMaster
//Date			Mon 21 Jul 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::DeleteServiceList()
{
	LPENUMSERVICE temp1,temp2;
	temp1=ServiceList;

	while (temp1)
	{
		delete[]temp1->sname;
		delete[]temp1->connection;

		temp2=temp1->Next;
		temp1->Next=NULL;

		delete temp1;

		temp1=temp2;
	}
	ServiceList=NULL;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		CreateDPlayInterface
//Author		Andy McMaster
//Date			Wed 26 Nov 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::CreateDPlayInterface()
{
	HRESULT res;

	res = CoCreateInstance( CLSID_DirectPlay, NULL, CLSCTX_INPROC_SERVER, 
		IID_IDirectPlay4A, (LPVOID*)&lpDP4);
	
	lpAppGuid=(LPGUID)&MIGALLEY_GUID;						//AMM 23Sep97

	if (res!=DP_OK)
		return FALSE;

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		CountPlayers
//Author		Andy McMaster
//Date			Wed 10 Dec 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::CountPlayers()
{
	CurrPlayers=0;

	for (ULong n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].status!=CPS_NONE)
			CurrPlayers++;
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		EnumConnectionsCallback
//Author		Andy McMaster
//Date			Wed 26 Nov 1997
//
//Description	Gets list of service providers and put them
//				into ServiceList
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
BOOL WINAPI	EnumConnectionsCallback(LPCGUID lpguidSP,
									LPVOID lpConnection,
									DWORD dwConnectionSize,
									LPCDPNAME lpName,
									DWORD dwFlags,
									LPVOID pContext)
{
	ULong namelen;
	LPENUMSERVICE temp=_DPlay.ServiceList;

	if (lpguidSP)
	{
		LPENUMSERVICE nextservice=new ENUMSERVICE;

		nextservice->Next=NULL;

		nextservice->sid=*lpguidSP;

		namelen=strlen(lpName->lpszShortNameA);
		nextservice->sname=new char[namelen+1];

		strcpy(nextservice->sname,lpName->lpszShortNameA);

		nextservice->connsize=dwConnectionSize;
		nextservice->connection=new UByte[dwConnectionSize];

		memcpy(nextservice->connection,lpConnection,dwConnectionSize);

		if (_DPlay.ServiceList==NULL)
		{
			_DPlay.ServiceList=nextservice;
		}
		else
		{
			while (temp->Next)
				temp=temp->Next;

			temp->Next=nextservice;
		}

		nextservice=NULL;
	}

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		EnumSessionsCallback
//Author		Andy McMaster
//Date			Wed 26 Nov 1997
//
//Description	Get list of session names for player to choose from
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
BOOL WINAPI EnumSessionsCallback(LPCDPSESSIONDESC2 lpSessionDesc,
								LPDWORD lpdwTimeOut,
								DWORD dwFlags,
								LPVOID lpContext)
{
	ULong namelen;
	LPENUMSESSION temp=_DPlay.SessionList;

	if (lpSessionDesc)
	{
		LPENUMSESSION newsess=new ENUMSESSION;

		newsess->Next=NULL;
		namelen=strlen(lpSessionDesc->lpszSessionNameA);
		newsess->sname=new char[namelen+1];

		strcpy(newsess->sname,lpSessionDesc->lpszSessionNameA);

		if (_DPlay.SessionList==NULL)
		{
			_DPlay.SessionList=newsess;
		}
		else
		{
			while (temp->Next)
				temp=temp->Next;

			temp->Next=newsess;
		}

		newsess=NULL;

		return TRUE;
	}
	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		EnumSessionsDataCallback
//Author		Andy McMaster
//Date			Wed 26 Nov 1997
//
//Description	Get data of session chosen by player and copy into dpsessiondesc2
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
BOOL WINAPI EnumSessionsDataCallback(LPCDPSESSIONDESC2 lpSessionDesc,
								LPDWORD lpdwTimeOut,
								DWORD dwFlags,
								LPVOID lpContext)
{
	if (lpSessionDesc)
	{
		if (!strcmp((char*)lpContext, lpSessionDesc->lpszSessionNameA))
		{
			_DPlay.tempdpsessdesc2=new char[sizeof(DPSESSIONDESC2)];
			memcpy(_DPlay.tempdpsessdesc2,lpSessionDesc,sizeof(DPSESSIONDESC2));

			return FALSE;
		}
		return TRUE;
	}
	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		CopyBuffer
//Author		Andy McMaster
//Date			Wed 10 Dec 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::CopyBuffer(char* dest, char* src, ULong size)
{
	memcpy (dest,src,size);
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ProcessSystemMessage
//Author		Andy McMaster
//Date			Wed 10 Dec 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::ProcessSystemMessage(char* message, UByte ctrl) //,ULong size)
{
	LPDPMSG_GENERIC Mess,Mess2;
	ULong n;
	
	Mess=(LPDPMSG_GENERIC)message;

	switch (Mess->dwType)
	{
		case DPSYS_ADDGROUPTOGROUP:
			LPDPMSG_ADDGROUPTOGROUP Mess2;

			Mess2=(LPDPMSG_ADDGROUPTOGROUP)message;
			break;

		case DPSYS_ADDPLAYERTOGROUP:
			LPDPMSG_ADDPLAYERTOGROUP Mess3;

			Mess3=(LPDPMSG_ADDPLAYERTOGROUP)message;

			lpDP4->AddPlayerToGroup(Mess3->dpIdGroup,Mess3->dpIdPlayer);
			break;

		case DPSYS_CHAT:
			LPDPMSG_CHAT Mess4;

			Mess4=(LPDPMSG_CHAT)message;
			break;

		case DPSYS_CREATEPLAYERORGROUP:
			LPDPMSG_CREATEPLAYERORGROUP Mess5;

			Mess5=(LPDPMSG_CREATEPLAYERORGROUP)message;
			break;

		case DPSYS_DELETEGROUPFROMGROUP:
			LPDPMSG_DELETEGROUPFROMGROUP Mess6;

			Mess6=(LPDPMSG_DELETEGROUPFROMGROUP)message;
			break;

		case DPSYS_DELETEPLAYERFROMGROUP:
			LPDPMSG_DELETEPLAYERFROMGROUP Mess7;

			Mess7=(LPDPMSG_DELETEPLAYERFROMGROUP)message;

			lpDP4->DeletePlayerFromGroup(Mess7->dpIdGroup,Mess7->dpIdPlayer);

			break;

		case DPSYS_DESTROYPLAYERORGROUP:
			LPDPMSG_DESTROYPLAYERORGROUP Mess8;

			Mess8=(LPDPMSG_DESTROYPLAYERORGROUP)message;

			if (Mess8->dwPlayerType==DPPLAYERTYPE_PLAYER)
			{
				for (n=0;n<MAXPLAYERS;n++)
				{
					if (Mess8->dpId==H2H_Player[n].dpid)
						break;
				}

				if (n==MAXPLAYERS)
					break;

// remove player from 3D if in 3D, and then from game

				bool	wasin3d=false;
//DEADCODE AMM 17/06/99 				ULong	slot=ID2Slot(Mess8->dpId);
				ULong	slot=DPID2Slot(Mess8->dpId);

				if (slot<MAXPLAYERS)
				{
					if (H2H_Player[slot].status==CPS_3D)
						wasin3d=true;
				}
				
				ProcessPlayerGone(Mess8->dpId,TRUE); 
				ProcessPlayerGone(Mess8->dpId,FALSE); 

				if (ctrl==CPS_READYROOM)
					DisplayInfo=TRUE;

				if (Mess8->dpId==H2H_Player[0].dpid)
				{
// host has gone - lets go as well

					LeaveCommsFlag=TRUE;
					HostQuitFlag=TRUE;
				}
				else if (Host && ResyncPhase && wasin3d)
				{
// if player has left game whilst in sync phase then host restarts sync

					Initiator=TRUE;
					BeginSyncPhase();
				}
			}
			break;

		case DPSYS_HOST:
			LPDPMSG_HOST Mess9;

			Mess9=(LPDPMSG_HOST)message;

			LeaveCommsFlag=TRUE;
			HostQuitFlag=TRUE;

			break;

		case DPSYS_SECUREMESSAGE:
			LPDPMSG_SECUREMESSAGE Mess10;

			Mess10=(LPDPMSG_SECUREMESSAGE)message;
			break;

		case DPSYS_SESSIONLOST:
			LPDPMSG_SESSIONLOST Mess11;

			Mess11=(LPDPMSG_SESSIONLOST)message;

			LeaveCommsFlag=TRUE;

			break;

		case DPSYS_SETPLAYERORGROUPDATA:
			LPDPMSG_SETPLAYERORGROUPDATA Mess12;

			Mess12=(LPDPMSG_SETPLAYERORGROUPDATA)message;
			break;

		case DPSYS_SETPLAYERORGROUPNAME:
			LPDPMSG_SETPLAYERORGROUPNAME Mess13;

			Mess13=(LPDPMSG_SETPLAYERORGROUPNAME)message;
			break;

		case DPSYS_SETSESSIONDESC:
			LPDPMSG_SETSESSIONDESC Mess14;

			Mess14=(LPDPMSG_SETSESSIONDESC)message;
			break;

		case DPSYS_STARTSESSION:
			LPDPMSG_STARTSESSION Mess15;

			Mess15=(LPDPMSG_STARTSESSION)message;
			break;

		case DPSYS_SENDCOMPLETE:
			LPDPMSG_SENDCOMPLETE Mess16;

			Mess16=(LPDPMSG_SENDCOMPLETE)message;

// dont care about complete sends, I dont care if messages are sent or not!!!!
// anyway these messages should not arrive as I turn them off.....
			break;

		case DPSYS_SETGROUPOWNER:
			LPDPMSG_SETGROUPOWNER Mess17;

			Mess17=(LPDPMSG_SETGROUPOWNER)message;

			break;

		default:
//DeadCode AMM 14Dec98 			_Error.SayAndQuit("Unknown system message!!!!!!!!!!!!!!!!!");
//DeadCode AMM 12May99 			INT3;
// some future version of direct play may use other messages so dont error
			break;
	}

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ProcessPlayerMessage
//Author		Andy McMaster
//Date			Wed 10 Dec 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::ProcessPlayerMessage(char* message,ULong size,ULong from,UByte ctrl)
{
	Bool	retval=TRUE;
	PUIPLAYERDATA pUIPlayerData = (PUIPLAYERDATA)message;
	UIPLAYERDATA UIPlayerData;
	PGAMEAVAILABLEPACKET gap;
	LPPASSWORDPACK ppack;
	PINITINFO ipack;
	ULong n;
 	UILOOKUPTABLE ltable;
	SLong senders_slot=-1;
	UByteP temp;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].dpid==from)
		{
			senders_slot=n;
			break;
		}
	}

	switch (pUIPlayerData->PacketID)
	{
		case PID_CSSTRUC:
			Process_PM_CSStruc(message);
			break;
			
		case PID_AAAPACKET:
			break;

		case PID_RANDOMLIST:
			ProcessRandomList(message);
			break;

		case PID_RANDREQUEST:
			if (Host)
			{
				SendBackupRandomList(true);
//DeadCode AMM 18Jun99 				SendMessageToPlayers((char*)&_Replay.BackupRndPacket, ( RNDPACKETSIZE * sizeof (UWord)) );
			}
			break;

		case PID_QUITACCEL:
			if (H2H_Player[mySlot].status==CPS_3D)
			{
				ProcessQuitAccelMessage(senders_slot);
			}
			break;
		case PID_CAMPAIGNSTRUC:
			break;

		case PID_SINGLEPILOTSTATUS:
			ProcessPilotStatusPacket(true,(UByteP)message);
			break;
		case PID_ALLPILOTSSTATUS:
			ProcessPilotStatusPacket(false,(UByteP)message);
			ApplyBackupPilots();
			break;

		case PID_NUMDEADBLOCKS:
			break;
		case PID_DEADBLOCKDATA:
			break;

		case PID_RESTARTWORLDSYNC:
			RestartWorldSync=true;
			break;

		case PID_NEWPLAYER:
		case PID_PLAYERUPDATE:

			CopyBuffer((char*)&H2H_Player[pUIPlayerData->Slot],(char*)&pUIPlayerData->playerinfo,sizeof(H2HPlayerInfo));

// display data

			if (ctrl==CPS_READYROOM)
				DisplayInfo=TRUE;

			break;

		case PID_IMHERE:

			for (n=0;n<MAXPLAYERS;n++)
			{
				if (n==pUIPlayerData->PlayerID)
				{
					H2H_Player[n].dpid=from;
					H2H_Player[n].status=CPS_READYROOM;
				}
			}

			break;

		case PID_PLAYERQUIT:

			if (senders_slot==0)
			{
// Host quit - chuck all players back to intro screen

				MyTeamKills=0;
				MyTeamDeaths=0;
//DeadCode AMM 17May99 				MyTeamFFKills=0;

				EnemyTeamKills=0;
				EnemyTeamDeaths=0;
//DeadCode AMM 17May99 				EnemyTeamFFKills=0;

				retval=FALSE;

				SimulateExitKey=TRUE; 
				LeaveCommsFlag=TRUE;
				
				break;
			}
			else
			{
				ProcessPlayerGone(from,FALSE);

				if (ctrl==CPS_READYROOM)
					DisplayInfo=TRUE;
				UpdateFrag=TRUE; // get rid of player from frag screen
			}
			break;

		case PID_MESSAGE:
//DeadCode DAW 01Nov99 #ifndef	MIG_DEMO_VER
			if (pUIPlayerData->PlayerID==255
			|| (pUIPlayerData->PlayerID==128 && pUIPlayerData->playerinfo.MyTeam==H2H_Player[mySlot].MyTeam)
			|| (pUIPlayerData->PlayerID==mySlot))
			{
				if (ctrl==CPS_READYROOM)
					DisplayReadyDialogue(pUIPlayerData->playerinfo.name,pUIPlayerData->playerinfo.dialogue);
#ifndef	MIG_DEMO_VER
				else if (ctrl==CPS_FRAG)
					DisplayFragDialogue(pUIPlayerData->playerinfo.name,pUIPlayerData->playerinfo.dialogue);
#endif #ifndef	MIG_DEMO_VER
			}
			AddChatMessageToBuffer(pUIPlayerData->playerinfo.name,pUIPlayerData->playerinfo.dialogue);
//DeadCode DAW 01Nov99 #endif #ifndef	MIG_DEMO_VER
			break;

		case PID_REQUESTSLOT:

			if(Host && AllowJoins)
			{
				SLong nextslot=GetNextAvailableSlot();

				if (nextslot>=0)
				{
					if (SendSlot(from,nextslot))
					{
						H2H_Player[nextslot].dpid=from;
						H2H_Player[nextslot].status=CPS_JOINING;
					}
				}
			}
			break;

		case PID_DATAREQUEST:

// this is called firsttime in to get players info
// Send PID_PLAYERUPDATE - copy info in packet h2hplayer

			SendMyPlayerInfo(true);

			if (Host)
			{
				UISendPrefs (true);
				if (GameType==COMMSQUICKMISSION)
				{
// send as an init packet so that players currently in do not get positions reset

					SendCSQuickStrucToPlayers(TRUE);
//DeadCode DAW 27Jun99 					SendCSQuickStrucToPlayers(FALSE);
				}
			}
			
			break;

		case PID_INPAINTSHOP:

			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_PAINTSHOP;

			DisplayInfo=TRUE;

			break;

		case PID_INPREFS:

			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_PREFS;

			DisplayInfo=TRUE;

			break;
		 
		case PID_INFRAG:

			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_FRAG;

			DisplayInfo=TRUE;

			break;
		 
		case PID_INMAP:

			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_MAP;

			DisplayInfo=TRUE;

			break;
		 
		case PID_INMISSIONBRIEF:

			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_MISSIONBRIEF;

			DisplayInfo=TRUE;

			break;
		 
		case PID_INRADIO:

			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_RADIO;

			DisplayInfo=TRUE;

			break;
		 
		case PID_INREADYROOM:

			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_READYROOM;

			DisplayInfo=TRUE;

			break;
		 
		case PID_INVISITORS:

			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_VISITORBOOK;

			DisplayInfo=TRUE;

			break;

		case PID_INDEBRIEF:
			if (senders_slot!=-1)
				H2H_Player[senders_slot].status=CPS_DEBRIEF;

			DisplayInfo=TRUE;

			break;
		 
		case PID_PREFSDATA:

			if (H2H_Player[mySlot].status!=CPS_3D)
			{
				ProcessPrefsPacket(message);
			}
			break;

		case PID_FLYNOW:

			if (!Host
			&& 	(H2H_Player[mySlot].status==CPS_READYROOM || H2H_Player[mySlot].status==CPS_FRAG))
			{
				FlyNowFlag = TRUE;
				return FALSE;
			}
			break;

		case PID_PLAYERLEAVINGGAME:

			if (senders_slot!=-1)
				H2H_Player[senders_slot].status=CPS_READYROOM;

			break;

		case PID_IAMIN:

			if (H2H_Player[mySlot].status==CPS_3D)
			{
				ULong slot;
				LPALLOCREQUEST arpack=(LPALLOCREQUEST)pUIPlayerData;
				
				slot=arpack->Slot;
				H2H_Player[slot].status=CPS_3D;
				AddPlayerToGame(slot,arpack->PlayerID,arpack->id);
				DisplayPlayerJoiningMessage(senders_slot);
			}
			else
			{
				if (senders_slot!=-1)
					H2H_Player[senders_slot].status=CPS_3D;
			}

			break;

		case PID_GAMEAVAILABLE:

			gap=(PGAMEAVAILABLEPACKET)pUIPlayerData;
			GameAvailable=gap->available;
			break;

		case PID_PASSWORD:

			if (Host)
			{
				ppack=(LPPASSWORDPACK)message;

				CheckPassword(ppack->pword,ppack->name,from);
			}
			break;

		case PID_VISITORUPDATE:

			if (Host)
			{
				ipack=(PINITINFO)message;
				AddNameToVisitorsBook(ipack->Name);
			}
			break;

		case PID_SYNC:

			for (n=0;n<MAXPLAYERS;n++)
			{
				if (H2H_Player[n].dpid==from)
				{
					SyncPacks[n]++;

					if (!(SyncBits & (1<<n)))
					{
						SyncBits |= (1 << n);
						SyncPacks[n]--;
					}
					break;
				}
			}
			break;

		case PID_NEEDRESYNC:

			if (H2H_Player[mySlot].status==CPS_3D && !Joining)
			{
				if (!ResyncPhase)
				{ 
					BeginSyncPhase();
					return FALSE;
				}
			}
			break;

		case PID_ISTHEREAGAME:
			if (Host)
			{
// only game in progress if host is in 3d and flying along nicely

				if (H2H_Player[mySlot].status==CPS_3D) 
				{
	   				SendGameAvailableMessage(TRUE);
				}
				else
				{
	   				SendGameAvailableMessage(FALSE);
				}
			}
			break;

		case PID_PREFSREQUEST:

			if (Host)
			{
				if (!UISendPrefs(true))
					_Error.SayAndQuit("Error sending prefs");
			}
//DeadCode AMM 16Jun99 			DisplayPlayerJoiningMessage();
			break;

		case PID_ALLOCREQUEST:

			if (Host)
			{
				for (n=0;n<MAXPLAYERS;n++)
				{
					if (H2H_Player[n].dpid==from)
						AllocPacket[n]=((LPALLOCREQUEST)message)->id;
				}

				ltable.PacketID=PID_ALLOCPACKET;
				ltable.PlayerID=myDPlayID;

				for (n=0;n<MAXPLAYERS;n++)
				{
					ltable.Table[n]=AllocPacket[n];
				}

				SendMessageToPlayers((char*)&ltable,sizeof(UILOOKUPTABLE));
			}
			break;

		case PID_BFIELDREQUEST:

			if (Host)
			{
				SendBFieldsToPlayers(true);
			}
			break;

		case PID_SLOTREQUEST:
			if (Host && AllowJoins)
			{
				ProcessPlayerSlotRequest(message,from,ctrl);
			}
			break;

		case PID_SLOTINFOUPDATE:
//DeadCode AMM 17Nov98 			if (!Host)
			{
				ProcessSlotInfoUpdate(message);
			}
			break;

		case PID_GAMEDETAILSREQUEST:
			if (Host)
				SendGameDetails();
			break;

		case PID_PLAYERINFOREQUEST:
			SendMyPlayerInfo(true);
			break;

//DeadCode DAW 21Feb00 		case PID_CSQUICKINFO:
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 			if (!Host)
//DeadCode DAW 21Feb00 			{
//DeadCode DAW 21Feb00 // mission has changed, unassign all player slots
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 				for (n=0;n<MAXPLAYERS;n++)
//DeadCode DAW 21Feb00 				{
//DeadCode DAW 21Feb00 					H2H_Player[n].squadron=-1;
//DeadCode DAW 21Feb00 					H2H_Player[n].position=-1;
//DeadCode DAW 21Feb00 				}
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 				MMC.playersquadron=-1;
//DeadCode DAW 21Feb00 				MMC.playeracnum=-1;
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 				LPCSQUICKSTRUC cspack=(LPCSQUICKSTRUC)message;
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 				UpdateCSQuick((UByte*)cspack->csquick,cspack->newmissionnum);
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 				if (H2H_Player[mySlot].status==CPS_FRAG)
//DeadCode DAW 21Feb00 					FragChanged=true;
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 // want to update mission name
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 				DisplayInfo=TRUE;
//DeadCode DAW 21Feb00 			}
//DeadCode DAW 21Feb00 			break;

		case PID_CSQUICKREQUEST:
			if (Host)
			{
				if (GameType!=COMMSCAMPAIGN)					//DAW 22Jun99
					SendCSQuickStrucToPlayers(TRUE);

				if (GameType>TEAMPLAY)
					SendPilotsStatus(false);

				if (GameType==COMMSCAMPAIGN)
//DeadCode AMM 18Jan99 				SendBinaryBattlefield();
					SendSaveGame(false,true);
				else if (GameType==COMMSQUICKMISSION)
					SendCampaignStruc(true);
			}

			break;

		case PID_MISSCONDSREQUEST:
			if (Host)
				SendMissionConditions(true);
			break;

		case PID_MESSAGES:
			ReceiveMessages((UByte*)message,from);
			break;

		case PID_MESSAGESREQUEST:
			SendMyMessages(true);
			break;

		case PID_SAVEGAME:
			if (!Host && H2H_Player[mySlot].status!=CPS_3D)
 				ReceiveSaveGame(false,((PCOMMONDATA)message)->PlayerID,((PCOMMONDATA)message)->Slot);

			if (H2H_Player[mySlot].status==CPS_FRAG)	//AMM 07/06/99
					FragChanged=true;					//AMM 07/06/99
			break;

//DeadCode AMM 13May99 		case PID_SAVEGAMESCORE:
//DeadCode AMM 13May99 			if (!Host)
//DeadCode AMM 13May99 			{
//DeadCode AMM 13May99 				ReceiveSaveGame(false,((PCOMMONDATA)message)->PlayerID,((PCOMMONDATA)message)->Slot);
//DeadCode AMM 13May99 
//DeadCode AMM 13May99 // quit if in 3d
//DeadCode AMM 13May99 
//DeadCode AMM 13May99 				if (H2H_Player[mySlot].status==CPS_3D)
//DeadCode AMM 13May99 					SimulateExitKey=TRUE;
//DeadCode AMM 13May99 			}
//DeadCode AMM 13May99 			break;

//DeadCode DAW 21Feb00 		case PID_CSQUICKINIT:
//DeadCode DAW 21Feb00 //DeadCode DAW 27Jun99 // only for players joining game - I already have this info
//DeadCode DAW 21Feb00 // when a player joins gets this packet, just for info purposes
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 			if (!Host)
//DeadCode DAW 21Feb00 			{
//DeadCode DAW 21Feb00 				LPCSQUICKSTRUC cspack=(LPCSQUICKSTRUC)message;
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 				UpdateCSQuick((UByte*)cspack->csquick,cspack->newmissionnum);
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 // want to update mission name
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 				DisplayInfo=TRUE;
//DeadCode DAW 21Feb00 			}
//DeadCode DAW 21Feb00 			break;
		case PID_GAMEDETAILSINFO:
// i'm already in game so I already have game details!
			break;
		case PID_RESYNC:
			if (H2H_Player[mySlot].status==CPS_3D) //AMM 17/05/99
				ProcessResyncPacket((LPACSTATEPACKET)message,senders_slot);
			break;

// should get processed elsewhere
		case PID_NEWSLOT:
// not for me, i already know my slot!
		case PID_ALLOCPACKET:
// picked up elsewhere
		case PID_PASSWORDVALID:
// hey, I'm already in session I know password....
//DeadCode AMM 15Apr99 		case PID_POSITIONDATA:
//DeadCode AMM 15Apr99 // erm, for future use...!!
		case PID_HOSTBUSY:
// so what, only interested if im joining
			break;

		case PID_ACDATA:
		case PID_MOBDATA:
		case PID_ITEMDATA:
		case PID_NUMACANIMS:
		case PID_NUMMOBANIMS:
		case PID_NUMITEMANIMS:
		case PID_ACANIM:
		case PID_MOBANIM:
		case PID_ITEMANIM:
		case PID_GOTWORLD:
//player may be joining, still ignore these packets though
//			INT3;
			break;

		case PID_BFIELDPACKETIDENT:
			break;

		case PID_READYWORLD:
//DEADCODE AMM 17/06/99 			SyncData.wsrgot+=1<<ID2Slot(from);
			SyncData.wsrgot+=1<<DPID2Slot(from);
//DeadCode AMM 18Mar99 			SyncData.wsrgot++;
			break;

		case PID_SAVEGAMEBINARY:
			break;

		case PID_HOSTLEAVING:
			SimulateExitKey=TRUE;
			HostQuit=true;

			break;

		case PID_GUESTLEAVING:
			ProcessGuestLeavingMessage(from);
			break;

		default:
#ifndef NDEBUG
			if (size==sizeof(ACPACKET))
				INT3;
#endif
//			_Error.SayAndQuit("Unprocessed Message ID=%d size=%d",pUIPlayerData->PacketID,size);
			break;
	}

	return retval;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendFlyNow
//Author		Andy McMaster
//Date			Mon 15 Dec 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::UISendFlyNow()
{
	UIPLAYERDATA UIPlayerData;

	UIPlayerData.PlayerID = myDPlayID;
	UIPlayerData.Slot = mySlot;
	UIPlayerData.PacketID = PID_FLYNOW;
	
	if (!SendMessageToPlayers ((char*)&UIPlayerData, sizeof(UIPLAYERDATA)))
	{
		return FALSE;
	}
	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UIUpdatePrefs
//Author		Andy McMaster
//Date			Mon 15 Dec 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::UIUpdatePrefs()
{
	ULong RecPacketLen;
	ULong from;
//DeadCode AMM 12May99 	char RecPacket[MAXCOMMSPACKETSIZE];
	char* RecPacket;

#ifdef CTRACE
	FILE* fp=fopen("ctrace.txt","at");
	fprintf(fp,"in UIUpdatePrefs\n");
#endif
// NEEDTIMEOUT
	if (Host)
	{
#ifdef CTRACE
		fprintf(fp,"Host\n");
#endif
		if (!UISendPrefs (false))
		{
#ifdef CTRACE
			fprintf(fp,"Failed to send\n\n");
			fclose(fp);
#endif
			return FALSE;
		}
	}
	else
	{
#ifdef CTRACE
		fprintf(fp,"Guest\n");
#endif
// Receive Prefs Packet

		ULong now=_Miles.GetSysTime();;

		CommsTimeout time(now,CommsTimeoutLength);

		for (;;)
		{
			now=_Miles.GetSysTime();

			if (time.TimedOut(now))
			{
#ifdef CTRACE
				fprintf(fp,"timed out in get prefs\n\n");
				fclose(fp);
#endif
				return FALSE;
			}
//				_Error.SayAndQuit("Timed out (UP)");


//DeadCode AMM 12May99 			RecPacketLen = MAXCOMMSPACKETSIZE;

			ULong to=myDPlayID;
//DeadCode AMM 12May99 			if (ReceiveNextMessage(RecPacket, RecPacketLen,from))
			if (ReceiveNextMessage(RecPacket, RecPacketLen,from,to,DPRECEIVE_TOPLAYER))
			{
#ifdef CTRACE
				fprintf(fp,"got message from ");
#endif
				if (from==0)
				{
#ifdef CTRACE
					fprintf(fp,"system\n");
#endif
					ProcessSystemMessage(RecPacket,RecPacketLen);
				}
				else if (from!=aggID)
				{
					PUIPLAYERDATA pUIPlayerData = (PUIPLAYERDATA)RecPacket;

					if (pUIPlayerData->PacketID == PID_PREFSDATA)
				   	{
#ifdef CTRACE
						fprintf(fp,"player - PID_PREFSDATA\n");
#endif
						ProcessPrefsPacket(RecPacket);
						break;

					}
					else
					{
#ifdef CTRACE
						fprintf(fp,"player ID=%x\n",pUIPlayerData->PacketID);
#endif
						ProcessPlayerMessage(RecPacket,RecPacketLen,from,CPS_GAMESTARTUP);
					}
				}
			}
		}
	}
#ifdef CTRACE
	fprintf(fp,"UpdatePrefs TRUE\n\n");
	fclose(fp);
#endif
	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		InitMainSheetInfo
//Author		Andy McMaster
//Date			Thu 18 Dec 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::InitMainSheetInfo()
{
	UIPLAYERDATA UIPlayerData;

// Signal this player is not in 3D

	(H2H_Player + mySlot)->status = CPS_READYROOM; // ready
	_DPlay.UpdateChatBox();

// Send PID_NEWPLAYER

	CopyBuffer((char*)(&UIPlayerData.playerinfo),(char*)(H2H_Player+mySlot),sizeof(H2HPlayerInfo));

	UIPlayerData.PlayerID = myDPlayID;
	UIPlayerData.Slot=mySlot;

	UIPlayerData.PacketID = PID_NEWPLAYER;

	SendMessageToPlayers ((char*)&UIPlayerData, sizeof(UIPLAYERDATA));

// Send DATA REQUEST for other players

	UIPlayerData.PlayerID = myDPlayID;
	UIPlayerData.Slot=mySlot;
	UIPlayerData.PacketID = PID_DATAREQUEST;

	SendMessageToPlayers ((char*)&UIPlayerData, sizeof(UIPLAYERDATA));

	if (Host)
		UISendPrefs (true);

	DisplayInfo=TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ConnectToAggregator
//Author		Andy McMaster
//Date			Mon 9 Feb 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::ConnectToAggregator(ULong& aggregatorID,char* Name)
{
	HRESULT res;
	DPSESSIONDESC2 DPSessionDesc2;

	char*	SessionName=new char[20];

	strcpy (SessionName,"Aggregator");

// Connect to an existing Session

	memset( &DPSessionDesc2, 0x00, sizeof(DPSESSIONDESC2));

	DPSessionDesc2.dwSize = sizeof (DPSESSIONDESC2);

	DPSessionDesc2.guidApplication = *lpAppGuid;
	DPSessionDesc2.lpszSessionNameA=new char[PLAYERNAMELEN];
	strcpy( DPSessionDesc2.lpszSessionNameA, SessionName);

// get session data

	res = lpDP4->EnumSessions (
		(LPDPSESSIONDESC2)&DPSessionDesc2,
		(DWORD)0,
		EnumSessionsDataCallback,
		(LPVOID)SessionName,
		(DWORD)(DPENUMSESSIONS_AVAILABLE|DPENUMSESSIONS_ASYNC)
		);

	if (res!=DP_OK)
		return FALSE;

	res=lpDP4->Open ( &DPSessionDesc2,DPOPEN_JOIN );

	if (res!=DP_OK)
		return FALSE;

	if (lpDP4->CreatePlayer ( &myDPlayID, NULL, NULL, NULL,0,0) != DP_OK)
		return FALSE;

	if (!GetMySlot())
		return FALSE;

	if (mySlot==1)
	{
		Host=TRUE;
	}
	else
		Host=FALSE;

// Init H2H_Player List

	InitH2HPArray();

// fill in name ,initial null dialogue, 0 kills and deaths 

	strcpy ((H2H_Player + mySlot)->name, PlayerName);
	(H2H_Player + mySlot)->status = CPS_READYROOM;
	strcpy ((H2H_Player + mySlot)->dialogue, "");

	PlayerCreated = TRUE;
	FlyNowFlag = FALSE;

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		StartCommsSession
//Author		Andy McMaster
//Date			Thu 11 Jun 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::StartCommsSession()
{
	if (!UIMultiPlayInit())
		return FALSE;

	UIAssignServices();

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		LaunchedByLobby
//Author		Andy McMaster
//Date			Fri 12 Jun 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode DAW 29Oct99 Bool	DPlay::LaunchedByLobby()
//DeadCode DAW 29Oct99 {
//DeadCode DAW 29Oct99 	HRESULT res;
//DeadCode DAW 29Oct99 	DWORD	size=0;
//DeadCode DAW 29Oct99 	LPDPLCONNECTION lpDPC;
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	CommsTimeoutLength=30000;
//DeadCode DAW 29Oct99 	network=false;
//DeadCode DAW 29Oct99 	RateDivider=5;
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 	strcpy(LobbyIPAddress,"1.2.3.4");
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	res=CoCreateInstance(CLSID_DirectPlayLobby,NULL,CLSCTX_INPROC_SERVER,
//DeadCode DAW 29Oct99 		IID_IDirectPlayLobby3A,(LPVOID*)&lpDPL);
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	if (res!=DP_OK)
//DeadCode DAW 29Oct99 	{
//DeadCode DAW 29Oct99 		ExitDirectPlay();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 		lpDPL=NULL;
//DeadCode DAW 29Oct99 		return FALSE;
//DeadCode DAW 29Oct99 	}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 /*
//DeadCode DAW 29Oct99 // go into wait mode
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	res=lpDPL->WaitForConnectionSettings(0);
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	bool ok=false;
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	DWORD		dwMsgFlags;
//DeadCode DAW 29Oct99 	char	buffer[2048];
//DeadCode DAW 29Oct99 	DWORD	buflen;
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	ULong now=_Miles.GetSysTime();
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	CommsTimeout time(now,CommsTimeoutLength);
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	while (true)
//DeadCode DAW 29Oct99 	{
//DeadCode DAW 29Oct99 		buflen=2048;
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 		dwMsgFlags=DPLMSG_SYSTEM;
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 		res=lpDPL->ReceiveLobbyMessage(0,0,&dwMsgFlags,buffer,&buflen);
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 		if (res==DP_OK)
//DeadCode DAW 29Oct99 		{
//DeadCode DAW 29Oct99 			if ((dwMsgFlags & DPLMSG_SYSTEM)
//DeadCode DAW 29Oct99 			&& ((LPDPLMSG_GENERIC)buffer)->dwType==DPLSYS_NEWCONNECTIONSETTINGS)
//DeadCode DAW 29Oct99 			{
//DeadCode DAW 29Oct99 				ok=true;
//DeadCode DAW 29Oct99 				break;
//DeadCode DAW 29Oct99 			}
//DeadCode DAW 29Oct99 		}
//DeadCode DAW 29Oct99 		else if (res!=DPERR_NOMESSAGES)
//DeadCode DAW 29Oct99 		{
//DeadCode DAW 29Oct99 			INT3;
//DeadCode DAW 29Oct99 		}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 		now=_Miles.GetSysTime();
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 		if (time.TimedOut(now))
//DeadCode DAW 29Oct99 		{
//DeadCode DAW 29Oct99 			ok=false;
//DeadCode DAW 29Oct99 			break;
//DeadCode DAW 29Oct99 		}
//DeadCode DAW 29Oct99 	}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	if (!ok)
//DeadCode DAW 29Oct99 	{
//DeadCode DAW 29Oct99 // timeout
//DeadCode DAW 29Oct99 	}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	lpDPL->WaitForConnectionSettings(DPLWAIT_CANCEL);
//DeadCode DAW 29Oct99 */
//DeadCode DAW 29Oct99 	res=lpDPL->GetConnectionSettings(0,NULL,&size);
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	if (res!=DP_OK && res!=DPERR_BUFFERTOOSMALL)
//DeadCode DAW 29Oct99 	{
//DeadCode DAW 29Oct99 		ExitDirectPlay();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 		lpDPL->Release();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 		lpDPL=NULL;
//DeadCode DAW 29Oct99 		return FALSE;
//DeadCode DAW 29Oct99 	}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	lpDPC=(LPDPLCONNECTION)(new char[size]);
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 	lpDPC=new DPLCONNECTION;
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	if (lpDPL->GetConnectionSettings(0,lpDPC,&size)!=DP_OK)
//DeadCode DAW 29Oct99 	{
//DeadCode DAW 29Oct99 		delete [] lpDPC;
//DeadCode DAW 29Oct99 		ExitDirectPlay();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 		lpDPL->Release();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 		lpDPL=NULL;
//DeadCode DAW 29Oct99 		return FALSE;
//DeadCode DAW 29Oct99 	}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 // set up session flags
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	lpDPC->lpSessionDesc->dwFlags=DPSESSION_DIRECTPLAYPROTOCOL	// need asyncronous send
//DeadCode DAW 29Oct99 								|DPSESSION_KEEPALIVE			// keep track of player falling out
//DeadCode DAW 29Oct99 								| DPSESSION_OPTIMIZELATENCY; // no nagling
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	lpDPC->lpSessionDesc->dwMaxPlayers=MAXPLAYERS+1;
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	res=lpDPL->SetConnectionSettings(0,0,lpDPC);
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	if (res!=DP_OK)
//DeadCode DAW 29Oct99 	{
//DeadCode DAW 29Oct99 		delete [] lpDPC;
//DeadCode DAW 29Oct99 		ExitDirectPlay();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 		lpDPL->Release();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 		lpDPL=NULL;
//DeadCode DAW 29Oct99 		return FALSE;
//DeadCode DAW 29Oct99 	}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 // if I am a guest then try to connect to the session
//DeadCode DAW 29Oct99 // host must wait until he has set up game options
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	if (!(lpDPC->dwFlags&DPLCONNECTION_CREATESESSION))
//DeadCode DAW 29Oct99 	{
//DeadCode DAW 29Oct99 		if (false)
//DeadCode DAW 29Oct99 		{
//DeadCode DAW 29Oct99 			if (lpDPL->ConnectEx(0,IID_IDirectPlay4A,(void**)&lpDP4,NULL)!=DP_OK)
//DeadCode DAW 29Oct99 			{
//DeadCode DAW 29Oct99 				delete [] lpDPC;
//DeadCode DAW 29Oct99 				ExitDirectPlay();
//DeadCode DAW 29Oct99 				return FALSE;
//DeadCode DAW 29Oct99 			}
//DeadCode DAW 29Oct99 		}
//DeadCode DAW 29Oct99 		else
//DeadCode DAW 29Oct99 		{
//DeadCode DAW 29Oct99 			ULong now=_Miles.GetSysTime();
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 // default timeout for ConnectEx is 60secs
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 			CommsTimeout time(now,60000);
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 			res=DPERR_CONNECTING;
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 			while (res==DPERR_CONNECTING)
//DeadCode DAW 29Oct99 			{
//DeadCode DAW 29Oct99 				res=lpDPL->ConnectEx(DPCONNECT_RETURNSTATUS,IID_IDirectPlay4A,(void**)&lpDP4,NULL);
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 				now=_Miles.GetSysTime();
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 				if (time.TimedOut(now))
//DeadCode DAW 29Oct99 				{
//DeadCode DAW 29Oct99 					delete [] lpDPC;
//DeadCode DAW 29Oct99 					ExitDirectPlay();
//DeadCode DAW 29Oct99 					return FALSE;
//DeadCode DAW 29Oct99 				}
//DeadCode DAW 29Oct99 			}
//DeadCode DAW 29Oct99 		}
//DeadCode DAW 29Oct99 	}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 	if (lpDPL->ConnectEx(0,IID_IDirectPlay4A,(void**)&lpDP4,NULL)!=DP_OK)
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 	{
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 		lpDPL->Release();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 		lpDPL=NULL;
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 		lpDP4=NULL;
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 		return FALSE;
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 	}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	lpAppGuid=(LPGUID)&MIGALLEY_GUID;					
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	if (lpDPC->dwFlags&DPLCONNECTION_CREATESESSION)
//DeadCode DAW 29Oct99 	{
//DeadCode DAW 29Oct99 		UIPlayerType=PLAYER_HOST;
//DeadCode DAW 29Oct99 		Host=TRUE;
//DeadCode DAW 29Oct99 		AllowJoins=TRUE;
//DeadCode DAW 29Oct99 	}
//DeadCode DAW 29Oct99 	else
//DeadCode DAW 29Oct99 	{
//DeadCode DAW 29Oct99 		UIPlayerType=PLAYER_GUEST;
//DeadCode DAW 29Oct99 		Host=FALSE;
//DeadCode DAW 29Oct99 	}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	if (lpDPC->lpPlayerName->lpszShortNameA)
//DeadCode DAW 29Oct99 	{
//DeadCode DAW 29Oct99 		strncpy (PlayerName,(char*)lpDPC->lpPlayerName->lpszShortNameA,59);
//DeadCode DAW 29Oct99 		PlayerName[59]=NULL;
//DeadCode DAW 29Oct99 	}
//DeadCode DAW 29Oct99 	else
//DeadCode DAW 29Oct99 	{
//DeadCode DAW 29Oct99 		strcpy(PlayerName,"Unnamed Player");
//DeadCode DAW 29Oct99 	}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	if (lpDPC->lpSessionDesc->lpszSessionNameA)
//DeadCode DAW 29Oct99 	{
//DeadCode DAW 29Oct99 		strncpy (SessionName,(char*)lpDPC->lpSessionDesc->lpszSessionName,59);
//DeadCode DAW 29Oct99 		SessionName[59]=NULL;
//DeadCode DAW 29Oct99 	}
//DeadCode DAW 29Oct99 	else
//DeadCode DAW 29Oct99 	{
//DeadCode DAW 29Oct99 		strcpy(SessionName,"Lobbied Game");
//DeadCode DAW 29Oct99 	}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	if (!Host)
//DeadCode DAW 29Oct99 	{
//DeadCode DAW 29Oct99 		if (!SetUpPlayer())
//DeadCode DAW 29Oct99 		{
//DeadCode DAW 29Oct99 			delete [] lpDPC;
//DeadCode DAW 29Oct99 			ExitDirectPlay();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 			lpDPL->Release();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 			lpDPL=NULL;
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 			lpDP4->Close();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 			lpDP4=NULL;
//DeadCode DAW 29Oct99 			return FALSE;
//DeadCode DAW 29Oct99 		}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 		if (!SetUpPlayerInfo(PlayerName))
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 		{
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 			lpDPL->Release();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 			lpDPL=NULL;
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 			lpDP4->Close();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 			lpDP4=NULL;
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 			return FALSE;
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 		}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 		if (UIPlayerType==PLAYER_GUEST)
//DeadCode DAW 29Oct99 		{
//DeadCode DAW 29Oct99 			if (!_DPlay.GetGameDetails())
//DeadCode DAW 29Oct99 			{
//DeadCode DAW 29Oct99 				delete [] lpDPC;
//DeadCode DAW 29Oct99 				CommsMessage(IDS_HOSTBUSY);
//DeadCode DAW 29Oct99 				ExitDirectPlay();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 				lpDPL->Release();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 				lpDPL=NULL;
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 				lpDP4->Close();
//DeadCode DAW 29Oct99 //DeadCode DAW 28Oct99 				lpDP4=NULL;
//DeadCode DAW 29Oct99 				return FALSE;
//DeadCode DAW 29Oct99 			}
//DeadCode DAW 29Oct99 		}
//DeadCode DAW 29Oct99 	}
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	delete [] lpDPC;
//DeadCode DAW 29Oct99 	Lobbied=TRUE;
//DeadCode DAW 29Oct99 
//DeadCode DAW 29Oct99 	return TRUE;
//DeadCode DAW 29Oct99 }
Bool	DPlay::LaunchedByLobbyCheck()
{
	HRESULT res;
	DWORD	size=0;

	CommsTimeoutLength=30000;
	network=false;
	RateDivider=5;

//DeadCode AMM 28Oct99 	strcpy(LobbyIPAddress,"1.2.3.4");

	res=CoCreateInstance(CLSID_DirectPlayLobby,NULL,CLSCTX_INPROC_SERVER,
		IID_IDirectPlayLobby3A,(LPVOID*)&lpDPL);

	if (res!=DP_OK)
	{
		ExitDirectPlay();
//DeadCode AMM 28Oct99 		lpDPL=NULL;
		return FALSE;
	}

	res=lpDPL->GetConnectionSettings(0,NULL,&size);

	if (res!=DP_OK && res!=DPERR_BUFFERTOOSMALL)
	{
		ExitDirectPlay();
//DeadCode AMM 28Oct99 		lpDPL->Release();
//DeadCode AMM 28Oct99 		lpDPL=NULL;
		return FALSE;
	}

	templpDPC=(new char[size]);

	LPDPLCONNECTION lpDPC=(LPDPLCONNECTION)templpDPC;

//DeadCode AMM 28Oct99 	lpDPC=new DPLCONNECTION;

	if (lpDPL->GetConnectionSettings(0,lpDPC,&size)!=DP_OK)
	{
		lpDPC=NULL;
		ExitDirectPlay();
//DeadCode AMM 28Oct99 		lpDPL->Release();
//DeadCode AMM 28Oct99 		lpDPL=NULL;
		return FALSE;
	}

// set up session flags

	lpDPC->lpSessionDesc->dwFlags=DPSESSION_DIRECTPLAYPROTOCOL	// need asyncronous send
								|DPSESSION_KEEPALIVE			// keep track of player falling out
								| DPSESSION_OPTIMIZELATENCY; // no nagling

	lpDPC->lpSessionDesc->dwMaxPlayers=MAXPLAYERS+1;

	res=lpDPL->SetConnectionSettings(0,0,lpDPC);

	if (res!=DP_OK)
	{
		lpDPC=NULL;
		ExitDirectPlay();
//DeadCode AMM 28Oct99 		lpDPL->Release();
//DeadCode AMM 28Oct99 		lpDPL=NULL;
		return FALSE;
	}

	lpDPC=NULL;
	PossibleLobby=true;

	_Replay.Record=FALSE;
	_Replay.Playback=FALSE;
	_Replay.BackupPrefs();										
 	Save_Data.gamedifficulty|=GD_VULNERABLE;
 	Save_Data.gamedifficulty|=GD_GROUNDCOLLISIONS;			
 	Save_Data.gamedifficulty|=GD_COLLISIONS;			
	Save_Data.flightdifficulty%=FD_AUTOTHROTTLE;

	return TRUE;
}

Bool DPlay::ConnectToLobby()
{
	HRESULT res;

// if I am a guest then try to connect to the session
// host must wait until he has set up game options

	if (!PossibleLobby)
		return FALSE;

	LPDPLCONNECTION lpDPC=(LPDPLCONNECTION)templpDPC;

	if (!(lpDPC->dwFlags&DPLCONNECTION_CREATESESSION))
	{
		if (false)
		{
			if (lpDPL->ConnectEx(0,IID_IDirectPlay4A,(void**)&lpDP4,NULL)!=DP_OK)
			{
				lpDPC=NULL;
				ExitDirectPlay();
				return FALSE;
			}
		}
		else
		{
			ULong now=_Miles.GetSysTime();

// default timeout for ConnectEx is 60secs

//			CommsTimeout time(now,60000);

			res=DPERR_CONNECTING;

//			while (res==DPERR_CONNECTING)
//			{
				res=lpDPL->ConnectEx(DPCONNECT_RETURNSTATUS,IID_IDirectPlay4A,(void**)&lpDP4,NULL);

//				now=_Miles.GetSysTime();

//				if (time.TimedOut(now))
//				{
//					delete [] lpDPC;
//					ExitDirectPlay();
//					return FALSE;
//				}
//			}
				if (res!=DP_OK)
				{
					lpDPC=NULL;
					return FALSE;
				}
		}
	}

	lpDPC=NULL;
	return TRUE;
}

Bool DPlay::FinishLobbySetup()
{

//DeadCode AMM 28Oct99 	if (lpDPL->ConnectEx(0,IID_IDirectPlay4A,(void**)&lpDP4,NULL)!=DP_OK)
//DeadCode AMM 28Oct99 	{
//DeadCode AMM 28Oct99 		lpDPL->Release();
//DeadCode AMM 28Oct99 		lpDPL=NULL;
//DeadCode AMM 28Oct99 		lpDP4=NULL;
//DeadCode AMM 28Oct99 		return FALSE;
//DeadCode AMM 28Oct99 	}

	LPDPLCONNECTION lpDPC=(LPDPLCONNECTION)templpDPC;

	lpAppGuid=(LPGUID)&MIGALLEY_GUID;					

	if (lpDPC->dwFlags&DPLCONNECTION_CREATESESSION)
	{
		UIPlayerType=PLAYER_HOST;
		Host=TRUE;
		AllowJoins=TRUE;
	}
	else
	{
		UIPlayerType=PLAYER_GUEST;
		Host=FALSE;
	}

	if (lpDPC->lpPlayerName->lpszShortNameA)
	{
		strncpy (PlayerName,(char*)lpDPC->lpPlayerName->lpszShortNameA,59);
		PlayerName[59]=NULL;
	}
	else
	{
		strcpy(PlayerName,"Unnamed Player");
	}

	if (lpDPC->lpSessionDesc->lpszSessionNameA)
	{
		strncpy (SessionName,(char*)lpDPC->lpSessionDesc->lpszSessionName,59);
		SessionName[59]=NULL;
	}
	else
	{
		strcpy(SessionName,"Lobbied Game");
	}

	if (!Host)
	{
		if (!SetUpPlayer())
		{
			lpDPC=NULL;
			ExitDirectPlay();
//DeadCode AMM 28Oct99 			lpDPL->Release();
//DeadCode AMM 28Oct99 			lpDPL=NULL;
//DeadCode AMM 28Oct99 			lpDP4->Close();
//DeadCode AMM 28Oct99 			lpDP4=NULL;
			return FALSE;
		}

//DeadCode AMM 28Oct99 		if (!SetUpPlayerInfo(PlayerName))
//DeadCode AMM 28Oct99 		{
//DeadCode AMM 28Oct99 			lpDPL->Release();
//DeadCode AMM 28Oct99 			lpDPL=NULL;
//DeadCode AMM 28Oct99 			lpDP4->Close();
//DeadCode AMM 28Oct99 			lpDP4=NULL;
//DeadCode AMM 28Oct99 			return FALSE;
//DeadCode AMM 28Oct99 		}

		if (UIPlayerType==PLAYER_GUEST)
		{
			if (!_DPlay.GetGameDetails())
			{
				lpDPC=NULL;
				CommsMessage(IDS_HOSTBUSY);
				ExitDirectPlay();
//DeadCode AMM 28Oct99 				lpDPL->Release();
//DeadCode AMM 28Oct99 				lpDPL=NULL;
//DeadCode AMM 28Oct99 				lpDP4->Close();
//DeadCode AMM 28Oct99 				lpDP4=NULL;
				return FALSE;
			}
		}
	}

	lpDPC=NULL;
	Lobbied=TRUE;

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SetUpPlayerInfo
//Author		Andy McMaster
//Date			Fri 12 Jun 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::SetUpPlayerInfo(char* name)
{
// determine capabilities

	DPCAPS dpCaps;
//DeadCode DAW 28Oct99 	LPDPLCONNECTION lpDPC=NULL;

	dpCaps.dwSize=sizeof(DPCAPS);

	if (lpDP4->GetCaps(&dpCaps,0)!=DP_OK)
		return FALSE;

	if(!Host)
	{
		if (!GetMySlot())
			return FALSE;
	}
	else
	{
		mySlot=0;
	}

	if (lpDP4->AddPlayerToGroup(playergroupID,myDPlayID))
		return FALSE;

	InitH2HPArray();

// fill in name ,initial null dialogue, 0 kills and deaths 

	(H2H_Player+mySlot)->dpid=myDPlayID;

// if there is no name use a default

	if (!strcmp(name,""))
		strcpy ((H2H_Player + mySlot)->name, "Unnamed Player");
	else
		strcpy ((H2H_Player + mySlot)->name, name);

	(H2H_Player + mySlot)->status = CPS_READYROOM;
	strcpy ((H2H_Player + mySlot)->dialogue, "");

	if (_DPlay.GameType!=DEATHMATCH)
	{
		if (Side)
			(H2H_Player+mySlot)->MyTeam=TS_UN;
		else
			(H2H_Player+mySlot)->MyTeam=TS_COMMIE;
	}
	else
	{
		(H2H_Player+mySlot)->MyTeam=TS_NONE;
	}

//	PlayerCreated = TRUE;
	FlyNowFlag = FALSE;

	sendtowho=255; // initially chat to everybody

// need to set up default AC for deathmatch/teamplay

	if (GameType==DEATHMATCH)
	{
		H2H_Player[mySlot].squadron=0;
	}
	else if (GameType==TEAMPLAY)
	{
		if (Side)
		{
			H2H_Player[mySlot].squadron=0;
		}
		else
		{
			H2H_Player[mySlot].squadron=SQ_R_FLYABLE;
		}
	}

	ChatBuffer.InitBuffer();

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		AddNameToVisitorsBook
//Author		Andy McMaster
//Date			Fri 12 Jun 1998
//
//Description	Only Host can add and remove name from the visitors book.
//				All other players must use SendUpdateToVisitorsBook to
//				alter it.
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::AddNameToVisitorsBook(char* name)
{
//DeadCode DAW 01Nov99 #ifndef	MIG_DEMO_VER
	if (Host && Password[0])
	{
		if (VisitorsBook)
		{
			LPVISITORINFO temp=VisitorsBook;

			while (temp)
			{
				if (!strcmp(temp->vis_name,name))
					return;

				temp=temp->next;
			}

			temp=VisitorsBook;

			while (temp->next)
			{
				temp=temp->next;
			}

			LPVISITORINFO a=new VISITORINFO;

			a->vis_status=FALSE;
			a->vis_name=new char[strlen(name)+1];
			strcpy(a->vis_name,name);
			a->next=NULL;
			temp->next=a;
			a=NULL;

			char temptext[256];
			strcpy(&temptext[0],name);
			strcat(&temptext[0]," has added name to visitor book");

			if ((H2H_Player+mySlot)->status==CPS_READYROOM)
				DisplayReadyDialogue("VISITOR",&temptext[0]);
#ifndef	MIG_DEMO_VER
			else
				DisplayFragDialogue("VISITOR",&temptext[0]);
#endif	#ifndef	MIG_DEMO_VER
		}
		else
		{
			VisitorsBook=new VISITORINFO;

			VisitorsBook->vis_name=new char[strlen(name)+1];

			strcpy(VisitorsBook->vis_name,name);
			VisitorsBook->vis_status=FALSE;
			VisitorsBook->next=NULL;

			char temptext[256];
			strcpy(&temptext[0],name);
			strcat(&temptext[0]," has added name to visitor book");

			if ((H2H_Player+mySlot)->status==CPS_READYROOM)
				DisplayReadyDialogue("VISITOR",&temptext[0]);
#ifndef	MIG_DEMO_VER
			else
				DisplayFragDialogue("VISITOR",&temptext[0]);
#endif
		}
	}
//DeadCode DAW 01Nov99 #endif	#ifndef	MIG_DEMO_VER
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		RemoveNameFromVisitorsBook
//Author		Andy McMaster
//Date			Fri 12 Jun 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::RemoveNameFromVisitorsBook(char* name)
{
	if (Host)
	{
		if (VisitorsBook)
		{
			LPVISITORINFO a,b;

			a=b=VisitorsBook;

			a=a->next;

			if (!strcmp(b->vis_name,name))
			{
				b->next=NULL;
				delete [] b->vis_name;
				delete b;
				VisitorsBook=a;
			}
			else
			{
				while (a)
				{
					if (!strcmp(a->vis_name,name))
					{
						b->next=a->next;

						a->next=NULL;
						delete [] a->vis_name;
						delete a;
						
						break;
					}
					a=a->next;
					b=b->next;
				}
			}
		}
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ToggleVisitorStatus
//Author		Andy McMaster
//Date			Fri 12 Jun 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::ToggleVisitorStatus(char* name)
{
	LPVISITORINFO a=VisitorsBook;

	while (a)
	{
		if (!strcmp(a->vis_name,name))
		{
			if (a->vis_status)
				a->vis_status=FALSE;
			else
				a->vis_status=TRUE;

			break;
		}

		a=a->next;
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendUpdateToVisitorsBook
//Author		Andy McMaster
//Date			Mon 15 Jun 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SendUpdateToVisitorsBook(char* name,Bool status)
{
	INITINFO info;
	ULong	from=myDPlayID,to=DPID_ALLPLAYERS; //,t=0;
	HRESULT res;

	info.ID=status;
	strcpy(info.Name,name);
	info.PacketID=PID_VISITORUPDATE;

	res=lpDP4->Send(from,to,0,&info,sizeof(INITINFO));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		LaunchEmpireLobby
//Author		Andy McMaster
//Date			Mon 15 Jun 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 16Jun99 void	DPlay::LaunchEmpireLobby()
//DeadCode AMM 16Jun99 {
//DeadCode AMM 16Jun99 }

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DeleteLobbyInfo
//Author		Andy McMaster
//Date			Mon 6 Jul 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::DeleteLobbyInfo()
{
	if (lpDPL)
		lpDPL->Release();
	lpDPL=NULL;

	if (templpDPC)
		delete [] templpDPC;
	templpDPC=NULL;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		RegisterApp
//Author		Andy McMaster
//Date			Mon 6 Jul 1998
//
//Description	put entry in registry for direct lobby
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 16Jun99 void	DPlay::RegisterApp()
//DeadCode AMM 16Jun99 {
//DeadCode AMM 16Jun99 // Heres the info, someone stick it in the registry
//DeadCode AMM 16Jun99 
//DeadCode AMM 16Jun99 /*
//DeadCode AMM 16Jun99 [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\DirectPlay\Applications\MigAlley]
//DeadCode AMM 16Jun99 "Guid"="{38305683-01EB-11d2-B1A4-004005247C2D}"
//DeadCode AMM 16Jun99 "File"="mig.exe"
//DeadCode AMM 16Jun99 "CommandLine"=""
//DeadCode AMM 16Jun99 "Path"="C:\mig\debug\exe"
//DeadCode AMM 16Jun99 "CurrentDirectory"="C:\mig\game"
//DeadCode AMM 16Jun99 */
//DeadCode AMM 16Jun99 
//DeadCode AMM 16Jun99 }

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		RunAggregatorFromReadyRoom
//Author		Andy McMaster
//Date			Tue 7 Jul 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::RunAggregatorFromReadyRoom()
{
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DeleteVisitorBook
//Author		Andy McMaster
//Date			Mon 13 Jul 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::DeleteVisitorBook()
{
	LPVISITORINFO a,b;

	a=VisitorsBook;

	while (a)
	{
		delete [] a->vis_name;
		b=a->next;
		delete a;
		a=b;
	}
	VisitorsBook=NULL;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DeleteSessionList
//Author		Andy McMaster
//Date			Tue 14 Jul 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::DeleteSessionList()
{
	LPENUMSESSION temp1,temp2;
	temp1=SessionList;

	while (temp1)
	{
		delete[]temp1->sname;

		temp2=temp1->Next;
		temp1->Next=NULL;

		delete temp1;

		temp1=temp2;
	}
	SessionList=NULL;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		CheckPassword
//Author		Andy McMaster
//Date			Tue 28 Jul 1998
//
//Description	check if password is correct and send message
//				
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::CheckPassword(char* pword,char* name,ULong player)
{
	ULong pwordOK=0;
	HRESULT res;
	ULong from=myDPlayID,to=player;
	COMMONDATA pack;

	if (!strcmp(pword,&Password[0]))
		pwordOK=1;
	else
	{
// check in visitors book

		LPVISITORINFO	temp=_DPlay.VisitorsBook;

		while (temp)
		{
			if (!strcmp(temp->vis_name,name))
			{
// found player

				if (temp->vis_status)
					pwordOK=1;

				break;
			}
			temp=temp->next;
		}
	}

	pack.PacketID=PID_PASSWORDVALID;
	pack.PlayerID=pwordOK;

	SendMessageToAll((char*)&pack,sizeof(COMMONDATA));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SetUpPlayer
//Author		Andy McMaster
//Date			Tue 28 Jul 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::SetUpPlayer()
{
	if(Host)
	{
// if I am the host then set up aggregator ID 
// create group and get ID

// aggregator gets its own thread - provide handle

//DeadCode AMM 17Aug98 		if (lpDP4->CreatePlayer ( &aggID, NULL, NULL, NULL,0,0)!=DP_OK)
		if (lpDP4->CreatePlayer ( &aggID, NULL, Master_3d.htable[Master_3d.EVENT_AGGREGATOR], NULL,0,0)!=DP_OK)
			return FALSE;

		if (lpDP4->CreateGroup( &playergroupID,NULL,NULL,0,0)!=DP_OK)
			return FALSE;
	}

	if (lpDP4->CreatePlayer ( &myDPlayID, NULL, NULL, NULL,0,0)!=DP_OK)
		return FALSE;

	PlayerCreated=TRUE;

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		AttemptToJoin
//Author		Andy McMaster
//Date			Tue 28 Jul 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::AttemptToJoin()
{
 	HRESULT res;
	PASSWORDPACK pack;
	ULong from=myDPlayID,to=DPID_ALLPLAYERS;
	Bool	result=FALSE;
//DeadCode AMM 12May99 	char	Buffer[MAXCOMMSPACKETSIZE];
	char* Buffer;
	ULong	Buflen;
	
	pack.PacketID=PID_PASSWORD;
	pack.PlayerID=myDPlayID;
	strncpy(&pack.pword[0],&Password[0],10);
	strcpy(&pack.name[0],&PlayerName[0]);


	res=lpDP4->Send(from,to,0,&pack,sizeof(PASSWORDPACK));

	if (res!=DP_OK)
		return FALSE;

// NEEDTIMEOUT

	ULong now=_Miles.GetSysTime();

	CommsTimeout time(now,CommsTimeoutLength);

	while (!result)
	{
		now=_Miles.GetSysTime();

		if (time.TimedOut(now))
			return FALSE;
//DeadCode AMM 09Apr99 			_Error.SayAndQuit("Timed out");

//DeadCode AMM 12May99 		Buflen=MAXCOMMSPACKETSIZE;

//DeadCode AMM 12May99 		res=lpDP4->Receive(&from,&to,0,(LPVOID)Buffer,&Buflen);

		if (ReceiveNextMessage(Buffer,Buflen,from,to,0))
//DeadCode AMM 12May99 		if (res==DP_OK)
		{
			pack=*(LPPASSWORDPACK)Buffer;

			if (pack.PacketID==PID_PASSWORDVALID)
				result=TRUE;
		}
	}

	if (pack.PlayerID!=0)
		return TRUE;

	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ReceiveNextMessage
//Author		Andy McMaster
//Date			Fri 7 Aug 1998
//
//Description	General receive routine.
//				All messages must be handled. (including system messages)
//				No excuses allowed!
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 12May99 Bool	DPlay::ReceiveNextMessage(char* data, ULong& len, ULong& from)
Bool	DPlay::ReceiveNextMessage(char*&data, ULong& len, ULong& from,ULong &To,ULong flags)
{
//DeadCode AMM 12May99 	char Buffer[MAXCOMMSPACKETSIZE];
//DeadCode AMM 12May99 	DWORD BufferLen = MAXCOMMSPACKETSIZE;
	HRESULT res;
//DeadCode AMM 12May99 	myDPID To=myDPlayID;
	bool got=false;
	bool reval=false;

	if (!PlayerCreated) 
		return FALSE;

// receive message to mydplayid in case I am aggregator. Dont want to receive packets 
// sent to aggregator here!!!!

	while (true)
	{
		res=lpDP4->Receive(&from, &To, flags, CommsPacketPtr, &CommsPacketLength);
		if (res==DPERR_BUFFERTOOSMALL)
		{
			delete [] CommsPacketPtr;
			CommsPacketPtr=new char[CommsPacketLength];
			if (!CommsPacketPtr)
				_Error.EmitSysErr("Out of memory");
		}
		else if (res==DP_OK)
		{
			data=CommsPacketPtr;
			len=CommsPacketLength;
			return TRUE;
		}
		else
			break;
	}

//DeadCode AMM 12May99 	res=lpDP4->Receive(&from, &To, DPRECEIVE_TOPLAYER, (LPVOID)Buffer, &BufferLen);
//DeadCode AMM 12May99 
//DeadCode AMM 12May99 	if (res!=DP_OK)
//DeadCode AMM 12May99 		return FALSE;
//DeadCode AMM 12May99 
//DeadCode AMM 12May99 	if (BufferLen>len)
//DeadCode AMM 12May99 		_Error.SayAndQuit("Packet too big for buffer: size=%d",BufferLen);
//DeadCode AMM 12May99 
//DeadCode AMM 12May99 	len=BufferLen;
//DeadCode AMM 12May99 	CopyBuffer(data,Buffer,len);
//DeadCode AMM 12May99 
//DeadCode AMM 12May99 	return TRUE;

	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendGameDetails
//Author		Andy McMaster
//Date			Tue 13 Oct 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SendGameDetails()
{
	GAMEDETAILS pack;
	COMMONDATA	cpack;

	if (AllowJoins)
	{
		pack.PacketID=PID_GAMEDETAILSINFO;
		pack.GameType=GameType;
		pack.GameIndex=GameIndex;
		pack.DataRate=RateDivider;

		SendMessageToAll((char*)&pack,sizeof(GAMEDETAILS));
	}
	else
	{
		cpack.PacketID=PID_HOSTBUSY;
		SendMessageToAll((char*)&cpack,sizeof(COMMONDATA));
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UpdatePlayerInfo
//Author		Andy McMaster
//Date			Wed 14 Oct 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::UpdatePlayerInfo()
{
//DeadCode AMM 12May99 	char RecPacket[MAXCOMMSPACKETSIZE];
	char* RecPacket;
	ULong	PlayRequestCount=0;;
	ULong from;
	ULong RecPacketLen;

#ifdef CTRACE
	FILE* fp=fopen("ctrace.txt","at");
	fprintf(fp,"in UpdatePlayerInfo\n");
#endif

	if (!SendMyPlayerInfo (true))
	{
#ifdef CTRACE
		fprintf(fp,"Send failed\n\n");
		fclose(fp);
#endif
		return FALSE;
	}
/*
// NEEDTIMEOUT
	ULong now=_Miles.GetSysTime();
	CommsTimeout time(now,CommsTimeoutLength);

	for (;;)
	{
		now=_Miles.GetSysTime();
		if (time.TimedOut(now))
		{
#ifdef CTRACE
			fprintf(fp,"timedout in updateplayerinfo\n\n");
			fclose(fp);
#endif
			return FALSE;
		}
//			_Error.SayAndQuit("Timed out (UPI)");

		if (PlayRequestCount == (CurrPlayers - 1))
		{
#ifdef CTRACE
			fprintf(fp,"got all updates\n");
#endif
			break;
		}

//DeadCode AMM 12May99 		RecPacketLen = MAXCOMMSPACKETSIZE;

		ULong to=myDPlayID;
//DeadCode AMM 12May99 		if (ReceiveNextMessage (RecPacket, RecPacketLen,from))
		if (ReceiveNextMessage (RecPacket, RecPacketLen,from,to,DPRECEIVE_TOPLAYER))
		{
#ifdef CTRACE
			fprintf(fp,"got message from ");
#endif
			if (from==0)
			{
#ifdef CTRACE
				fprintf(fp,"system\n");
#endif
				ProcessSystemMessage(RecPacket,CPS_GAMESTARTUP);
			}
			else if (from!=aggID)
			{
				PUIPLAYERDATA pack = (PUIPLAYERDATA)RecPacket;

				if (pack->PacketID == PID_PLAYERUPDATE)
				{
					PlayRequestCount++;
#ifdef CTRACE
					fprintf(fp,"player - PID_PLAYERUPDATE\n");
					fprintf(fp,"PlayRequestCount=%d currplayers=%d\n",PlayRequestCount,CurrPlayers);
#endif

					CopyBuffer((char*)&H2H_Player[pack->Slot],(char*)&pack->playerinfo,sizeof(H2HPlayerInfo));
				}
				else
				{
#ifdef CTRACE
					fprintf(fp,"player - ID=%x\n",pack->PacketID);
#endif
					ProcessPlayerMessage(RecPacket,RecPacketLen,from,CPS_GAMESTARTUP);
				}
			}
			else
			{
#ifdef CTRACE
				fprintf(fp,"AGGREGATOR!!!!!!!\n");
#endif
			}
		}
	}*/
#ifdef CTRACE
	fprintf(fp,"UpdatePlayerInfo TRUE\n\n");
	fclose(fp);
#endif
	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendMyPlayerInfo
//Author		Andy McMaster
//Date			Wed 14 Oct 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 13May99 void	DPlay::SendMyPlayerInfo()
bool	DPlay::SendMyPlayerInfo(bool request)
{
	UIPLAYERDATA pack;

	pack.PacketID=PID_PLAYERUPDATE;
	pack.Slot=mySlot; 

	CopyBuffer((char*)&pack.playerinfo,(char*)&H2H_Player[mySlot],sizeof(H2HPlayerInfo));

//DeadCode AMM 23May99 	if (!SendMessageToPlayers((char*)&pack,sizeof(UIPLAYERDATA)))
//DeadCode AMM 16Jun99 	if (H2H_Player[mySlot].status==CPS_3D)
	if (!request)
	{
		if (!SendGMessageToPlayersTimeout((char*)&pack,sizeof(UIPLAYERDATA)))
			return false;
	}
	else
	{
		SendMessageToPlayers((char*)&pack,sizeof(UIPLAYERDATA));
	}

	return true;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		GetNextAvailableSlot
//Author		Andy McMaster
//Date			Thu 22 Oct 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
SLong	DPlay::GetNextAvailableSlot()
{
	ULong n;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].status==CPS_NONE)
			return n;
	}

	return -1;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ProcessPrefsPacket
//Author		Andy McMaster
//Date			Wed 28 Oct 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::ProcessPrefsPacket(char* pack)
{
	PUIPREFSDATA pUIPrefsData;

	pUIPrefsData = (PUIPREFSDATA)pack;

// ignore Coordinated rudder, translucent smoke, priority messages, stick stiffness etc

	bool rud;														  //RDH 20/05/99
	Bool smoke,mess,stick;
	bool frate;														  //RDH 20/05/99
	bool	autopadlock;

	bool	ff_gun,ff_buffet,ff_aero,ff_frame; //DAW 08/11/99

	ff_gun=Save_Data.flightdifficulty[FD_FF_GUN]; //DAW 08/11/99
	ff_buffet=Save_Data.flightdifficulty[FD_FF_BUFFET]; //DAW 08/11/99
	ff_aero=Save_Data.flightdifficulty[FD_FF_AERODYNAMIC]; //DAW 08/11/99
	ff_frame=Save_Data.flightdifficulty[FD_FF_AIRFRAME]; //DAW 08/11/99

	frate=Save_Data.gamedifficulty[FRAME_RATE_DISPLAY];

	rud=Save_Data.flightdifficulty[FD_COORDINATEDRUDDER];

	autopadlock=Save_Data.gamedifficulty[GD_AUTOPADLOCKTOG];
//						smoke=Save_Data.gamedifficulty[GD_TRANSLUCENTSMOKE];//AMM 30Sep97
//						mess=Save_Data.gamedifficulty[GD_PRIORITYMESSAGES];//AMM 30Sep97
//						stick=Save_Data.gamedifficulty[GD_STICKSTIFFNESS];//AMM 30Sep97

	Save_Data.flightdifficulty	=	pUIPrefsData->flightdifficulty;
	Save_Data.gamedifficulty	=	pUIPrefsData->gamedifficulty;
	Save_Data.targetsize		=	pUIPrefsData->targetsize;
	Save_Data.autopilotskillUN	=	pUIPrefsData->autopilotskillUN;
	Save_Data.autopilotskillRED	=	pUIPrefsData->autopilotskillRED;


	if (ff_gun) //DAW 08/11/99
		Save_Data.flightdifficulty|=FD_FF_GUN; //DAW 08/11/99
	else //DAW 08/11/99
		Save_Data.flightdifficulty%=FD_FF_GUN; //DAW 08/11/99

	if (ff_buffet) //DAW 08/11/99
		Save_Data.flightdifficulty|=FD_FF_BUFFET; //DAW 08/11/99
	else //DAW 08/11/99
		Save_Data.flightdifficulty%=FD_FF_BUFFET; //DAW 08/11/99

	if (ff_aero) //DAW 08/11/99
		Save_Data.flightdifficulty|=FD_FF_AERODYNAMIC; //DAW 08/11/99
	else //DAW 08/11/99
		Save_Data.flightdifficulty%=FD_FF_AERODYNAMIC; //DAW 08/11/99

	if (ff_frame) //DAW 08/11/99
		Save_Data.flightdifficulty|=FD_FF_AIRFRAME; //DAW 08/11/99
	else //DAW 08/11/99
		Save_Data.flightdifficulty%=FD_FF_AIRFRAME; //DAW 08/11/99


	if (frate)										
		Save_Data.gamedifficulty|=FRAME_RATE_DISPLAY;
	else 											
		Save_Data.gamedifficulty%=FRAME_RATE_DISPLAY;

	if (autopadlock)
		Save_Data.gamedifficulty|=GD_AUTOPADLOCKTOG;
	else
		Save_Data.gamedifficulty%=GD_AUTOPADLOCKTOG;

//DeadCode AMM 08Apr99 	if (rud)									
//DeadCode AMM 08Apr99 		Save_Data.flightdifficulty|=FD_COORDINATEDRUDDER;
//DeadCode AMM 08Apr99 	else										
//DeadCode AMM 08Apr99 		Save_Data.flightdifficulty%=FD_COORDINATEDRUDDER;

//						if (smoke)									//AMM 30Sep97
//							Save_Data->gamedifficulty|=GD_TRANSLUCENTSMOKE;//AMM 30Sep97
//						else										//AMM 30Sep97
//							Save_Data->gamedifficulty%=GD_TRANSLUCENTSMOKE;//AMM 30Sep97

//						if (mess)									//AMM 30Sep97
//							Save_Data->gamedifficulty|=GD_PRIORITYMESSAGES;//AMM 30Sep97
//						else										//AMM 30Sep97
//							Save_Data->gamedifficulty%=GD_PRIORITYMESSAGES;//AMM 30Sep97

//						if (stick)									//AMM 30Sep97
//							Save_Data->gamedifficulty|=GD_STICKSTIFFNESS;//AMM 30Sep97
//						else										//AMM 30Sep97
//							Save_Data->gamedifficulty%=GD_STICKSTIFFNESS;//AMM 30Sep97

//DeadCode AMM 08Apr99 	RateDivider=pUIPrefsData->DataRate;			
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		AllPlayersHaveSlots
//Author		Andy McMaster
//Date			Tue 3 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::AllPlayersHaveSlots()
{
	UByte num=0,n;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].position!=-1 && H2H_Player[n].squadron!=-1)
		{
			num++;
		}
	}

	if (num==CurrPlayers)
		return TRUE;

	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendInFragMessage
//Author		Andy McMaster
//Date			Tue 3 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::SendInFragMessage ()
{
	COMMONDATA pack;

	pack.PacketID=PID_INFRAG;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendInMapMessage
//Author		Andy McMaster
//Date			Tue 3 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::SendInMapMessage ()
{
	if (!PlayerCreated) return;										  //JIM 25/01/99
	COMMONDATA pack;

	pack.PacketID=PID_INMAP;

	H2H_Player[mySlot].status=CPS_MAP;
	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendInMissionBriefMessage
//Author		Andy McMaster
//Date			Tue 3 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::SendInMissionBriefMessage ()
{
	COMMONDATA pack;

	pack.PacketID=PID_INMISSIONBRIEF;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendInRadioMessage
//Author		Andy McMaster
//Date			Tue 3 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::SendInRadioMessage ()
{
	COMMONDATA pack;

	pack.PacketID=PID_INRADIO;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendInReadyRoomMessage
//Author		Andy McMaster
//Date			Tue 3 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::SendInReadyRoomMessage ()
{
	COMMONDATA pack;

	pack.PacketID=PID_INREADYROOM;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendCS
//Author		Andy McMaster
//Date			Sun 8 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SendCS(UByte* info,ULong size, Bool init)
{
	CSQUICKSTRUC	pack;
	COMMONDATA g;
	ULong n;

	if (init)
	{
		pack.PacketID=PID_CSQUICKINIT;
	}
	else
	{
		pack.PacketID=PID_CSQUICKINFO;

// need to unassign all players as mission has changed

		for (n=0;n<MAXPLAYERS;n++)
		{
			H2H_Player[n].squadron=-1;
			H2H_Player[n].position=-1;
		}

		MMC.playersquadron=-1;
		MMC.playeracnum=-1;
	}

	ULong numpackets=size/500;

	if (size%500)
		numpackets++;

	g.PacketID=PID_CSSTRUC;
	g.PlayerID=numpackets;
	g.Slot=size;

	if (init)
	{
		SendMessageToAll((char*)&g, sizeof(COMMONDATA));
	}
	else
	{
		SendMessageToAll((char*)&g, sizeof(COMMONDATA));
	}

	ULong	index=0;
	ULong	copysize;
	CSSTRUCPART csp;
	UByteP ptr=info;

	while (numpackets--)
	{
		csp.PacketID=PID_CSSTRUCBINARY;
		csp.index=index++;

		if (numpackets)
			copysize=500;
		else
			copysize=size%500;

		csp.size=copysize;
		csp.newmissionnum=GameIndex;

		CopyMemory(&csp.data,ptr,copysize);
		ptr+=copysize;

		if (init)
		{
			SendMessageToAll((char*)&csp,sizeof(CSSTRUCPART));
		}
		else
		{
			SendMessageToAll((char*)&csp,sizeof(CSSTRUCPART));
		}
	}
//DeadCode DAW 21Feb00 	memcpy(&pack.csquick,info,size);
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 	pack.newmissionnum=GameIndex;
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 	SendMessageToAll((char*)&pack,sizeof(CSQUICKSTRUC));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		GetCS
//Author		Andy McMaster
//Date			Sun 8 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::GetCS()
{
	char* Buffer;
	ULong	BufferLen=0;
	Bool	Got=FALSE;
//DeadCode DAW 21Feb00 	LPCSQUICKSTRUC pack;
	ULong From;
	ULong size,numparts;

	ULong now=_Miles.GetSysTime();
	CommsTimeout time(now,CommsTimeoutLength);

	while(!Got)
	{
		now=_Miles.GetSysTime();

		if (time.TimedOut(now))
			return FALSE;
		
		ULong to=0;
		if (ReceiveNextMessage(Buffer,BufferLen,From,to,0))
		{
			if (From==0)
			{
				ProcessSystemMessage(Buffer,CPS_NONE);
			}
			else if (BufferLen!=sizeof(AGGSENDPACKET))
			{
				if (((PCOMMONDATA)Buffer)->PacketID == PID_CSSTRUC)
				{
					size=((PCOMMONDATA)Buffer)->Slot;
					numparts=((PCOMMONDATA)Buffer)->PlayerID;
					Got=TRUE;
				}
			}
//DeadCode DAW 21Feb00 			else if (BufferLen==sizeof(CSQUICKSTRUC))
//DeadCode DAW 21Feb00 			{
//DeadCode DAW 21Feb00 // player is joining game so can ignore all other packets
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 				pack=(LPCSQUICKSTRUC)Buffer;
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 				if(pack->PacketID==PID_CSQUICKINIT)
//DeadCode DAW 21Feb00 				{
//DeadCode DAW 21Feb00 					GameIndex=pack->newmissionnum;
//DeadCode DAW 21Feb00 					UpdateCSQuick((UByte*)pack->csquick,pack->newmissionnum);
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 					Got=TRUE;
//DeadCode DAW 21Feb00 
//DeadCode DAW 21Feb00 //					return TRUE;
//DeadCode DAW 21Feb00 				}
//DeadCode DAW 21Feb00 			}
		}
	}
// get parts

	char* RecPacket;
	ULong RecPacketLen=0,from;
	ULong rec=0;
	UByte*	struc=new UByte[size];

	time.Init(now,(CommsTimeoutLength*2));

	while (rec!=numparts)
	{
		now=timeGetTime();

		if (time.TimedOut(now))
		{
			delete [] struc;
			return FALSE;
		}

		ULong to=0;
		if (ReceiveNextMessage (RecPacket, RecPacketLen,from,to,0))
		{
// if we are getting info about game initally dont bother with any other messages

			if (from!=0 && RecPacketLen!=sizeof(AGGSENDPACKET))
			{
				if(((PCOMMONDATA)RecPacket)->PacketID == PID_CSSTRUCBINARY)
				{
					LPCSSTRUCPART csp=(LPCSSTRUCPART)RecPacket;

					GameIndex=csp->newmissionnum;

					UByteP temp=struc;

					temp+=(csp->index)*500;

					CopyMemory(temp,csp->data,csp->size);

					rec++;
				}
			}
		}
	}

	UpdateCSQuick((UByte*)struc,GameIndex);

	delete [] struc;
	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		GetCSQuickStruc
//Author		Andy McMaster
//Date			Sun 8 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::GetCSQuickStruc()
{
	SendCSRequest();
	GetCS();
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendCSRequest
//Author		Andy McMaster
//Date			Sun 8 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SendCSRequest()
{
//DeadCode AMM 16Jun99 	CSQUICKSTRUC p;
	COMMONDATA p;
	p.PacketID=PID_CSQUICKREQUEST;
	ULong retries=10;											//AMM 07Jul99

//DeadCode AMM 16Jun99 	SendMessageToAll((char*)&p,sizeof(CSQUICKSTRUC));
//DeadCode AMM 07Jul99 	SendMessageToAll((char*)&p,sizeof(COMMONDATA));
	while (!SendMessageToAll((char*)&p,sizeof(COMMONDATA)))
	{
		ULong end=timeGetTime()+100; // 10th sec

		while (timeGetTime()<end)
		{
			Sleep(0);
		}
		retries--;

		if (!retries)
			break;
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendMyMessages
//Author		Andy McMaster
//Date			Wed 11 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 23May99 void	DPlay::SendMyMessages()
bool	DPlay::SendMyMessages(bool request)
{
	MESSAGEPACKET p;
	ULong n;

	p.PacketID=PID_MESSAGES;

	for (n=0;n<NUMRADIOMESSAGES;n++)
	{
		strcpy (p.messages[n],Messages[mySlot][n]);
	}

//DeadCode AMM 23May99 	SendMessageToPlayers((char*)&p,sizeof(MESSAGEPACKET));
	if (request)
	{
		if (SendMessageToAll((char*)&p,sizeof(MESSAGEPACKET)))
			return true;

		return false;
	}
	else
	{
		return (SendGMessageToPlayersTimeout((char*)&p,sizeof(MESSAGEPACKET)));
	}
//DeadCode AMM 16Jun99 	return (SendGMessageToPlayersTimeout((char*)&p,sizeof(MESSAGEPACKET)));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ReceiveMessages
//Author		Andy McMaster
//Date			Wed 11 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::ReceiveMessages(UByteP p,ULong from)
{
	ULong n,slot=0;
	LPMESSAGEPACKET m=(LPMESSAGEPACKET)p;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].dpid==from)
		{
			slot=n;
			break;
		}
	}

	if (n!=MAXPLAYERS)
	{
		for (n=0;n<NUMRADIOMESSAGES;n++)
		{
			strcpy(Messages[slot][n],m->messages[n]);
		}
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DisableJoins
//Author		Andy McMaster
//Date			Fri 13 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::DisableJoins()
{
	AllowJoins=FALSE;
//DeadCode AMM 17Nov98 	HRESULT res;
//DeadCode AMM 17Nov98 	LPDPSESSIONDESC2 DPSessionDesc2;
//DeadCode AMM 17Nov98 	ULong size=0;
//DeadCode AMM 17Nov98 	char*	bob;
//DeadCode AMM 17Nov98 
//DeadCode AMM 17Nov98 	res=lpDP4->GetSessionDesc(NULL,&size);
//DeadCode AMM 17Nov98 
//DeadCode AMM 17Nov98 	if (res==DPERR_BUFFERTOOSMALL)
//DeadCode AMM 17Nov98 	{
//DeadCode AMM 17Nov98 		bob=new char[size];
//DeadCode AMM 17Nov98 
//DeadCode AMM 17Nov98 		res=lpDP4->GetSessionDesc(bob,&size);
//DeadCode AMM 17Nov98 
//DeadCode AMM 17Nov98 		if (res==DP_OK)
//DeadCode AMM 17Nov98 		{
//DeadCode AMM 17Nov98 			DPSessionDesc2=(LPDPSESSIONDESC2)bob;
//DeadCode AMM 17Nov98 
//DeadCode AMM 17Nov98 			DPSessionDesc2->dwFlags|=DPSESSION_JOINDISABLED;
//DeadCode AMM 17Nov98 
//DeadCode AMM 17Nov98 			res=lpDP4->SetSessionDesc(DPSessionDesc2,NULL);
//DeadCode AMM 17Nov98 		}
//DeadCode AMM 17Nov98 
//DeadCode AMM 17Nov98 		delete [] bob;
//DeadCode AMM 17Nov98 	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		EnableJoins
//Author		Andy McMaster
//Date			Fri 13 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::EnableJoins()
{
	AllowJoins=TRUE;
//DeadCode AMM 17Nov98 	HRESULT res;
//DeadCode AMM 17Nov98 	LPDPSESSIONDESC2 DPSessionDesc2;
//DeadCode AMM 17Nov98 	ULong size=0;
//DeadCode AMM 17Nov98 	char*	bob;
//DeadCode AMM 17Nov98 
//DeadCode AMM 17Nov98 	res=lpDP4->GetSessionDesc(NULL,&size);
//DeadCode AMM 17Nov98 
//DeadCode AMM 17Nov98 	if (res==DPERR_BUFFERTOOSMALL)
//DeadCode AMM 17Nov98 	{
//DeadCode AMM 17Nov98 		bob=new char[size];
//DeadCode AMM 17Nov98 
//DeadCode AMM 17Nov98 		res=lpDP4->GetSessionDesc(bob,&size);
//DeadCode AMM 17Nov98 
//DeadCode AMM 17Nov98 		if (res==DP_OK)
//DeadCode AMM 17Nov98 		{
//DeadCode AMM 17Nov98 			DPSessionDesc2=(LPDPSESSIONDESC2)bob;
//DeadCode AMM 17Nov98 
//DeadCode AMM 17Nov98 			if (DPSessionDesc2->dwFlags&DPSESSION_JOINDISABLED)
//DeadCode AMM 17Nov98 			{
//DeadCode AMM 17Nov98 				DPSessionDesc2->dwFlags^=DPSESSION_JOINDISABLED;
//DeadCode AMM 17Nov98 			}
//DeadCode AMM 17Nov98 
//DeadCode AMM 17Nov98 			res=lpDP4->SetSessionDesc(DPSessionDesc2,NULL);
//DeadCode AMM 17Nov98 		}
//DeadCode AMM 17Nov98 
//DeadCode AMM 17Nov98 		delete [] bob;
//DeadCode AMM 17Nov98 	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SelectPlayerToChatTo
//Author		Andy McMaster
//Date			Tue 1 Dec 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SelectPlayerToChatTo(ULong playerslot)
{
	ULong realslot,n;
	SLong id=-1;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if ((H2H_Player+n)->MyTeam==TS_UN || (H2H_Player+n)->MyTeam==TS_NONE)
		{
			if (n==playerslot)
			{
				id=n;
				break;
			}
		}
	}

	if (id<0)
	{
		for (n=0;n<MAXPLAYERS;n++)
		{
			if ((H2H_Player+n)->MyTeam==TS_COMMIE)
			{
				if (n==playerslot)
				{
					id=n;
					break;
				}
			}
		}
	}

	if (id>=0)
	{
//DeadCode AMM 22Feb99 //		DeselectChatPlayer(); // restore previous sendtowho value
//DeadCode AMM 22Feb99 
//DeadCode AMM 22Feb99 		if (id==sendtowho)
//DeadCode AMM 22Feb99 		{
//DeadCode AMM 22Feb99 // same player clicked on twice means deselect player and restore old value
//DeadCode AMM 22Feb99 			sendtowho=oldsendtowho;
//DeadCode AMM 22Feb99 		}
//DeadCode AMM 22Feb99 		else 
//DeadCode AMM 22Feb99 		{
//DeadCode AMM 22Feb99 			if (sendtowho>127)
//DeadCode AMM 22Feb99 			{
//DeadCode AMM 22Feb99 				oldsendtowho=sendtowho;
//DeadCode AMM 22Feb99 			}
			sendtowho=id;
//DeadCode AMM 22Feb99 		}
	}
	else
	{
		sendtowho=255;
//DeadCode AMM 22Feb99 		oldsendtowho=255;
	}
}


//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SelectPlayerToChatTo
//Author		Andy McMaster
//Date			Mon 11 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SelectPlayerToChatTo(ULong position, ULong squadron)
{
	ULong n;
	SLong id=-1;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].position==position
		&& H2H_Player[n].squadron==squadron)
		{
			id=n;
			break;
		}
	}

	if (id>=0)
	{
//DeadCode AMM 22Feb99 		if (id==sendtowho)
//DeadCode AMM 22Feb99 		{
//DeadCode AMM 22Feb99 // same player clicked on twice means deselect player and restore old value
//DeadCode AMM 22Feb99 			sendtowho=oldsendtowho;
//DeadCode AMM 22Feb99 		}
//DeadCode AMM 22Feb99 		else 
//DeadCode AMM 22Feb99 		{
//DeadCode AMM 22Feb99 			if (sendtowho>127)
//DeadCode AMM 22Feb99 			{
//DeadCode AMM 22Feb99 				oldsendtowho=sendtowho;
//DeadCode AMM 22Feb99 			}
			sendtowho=id;
//DeadCode AMM 22Feb99 		}
	}
	else
	{
		sendtowho=255;
//DeadCode AMM 22Feb99 		oldsendtowho=255;
	}

}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DeselectChatPlayer
//Author		Andy McMaster
//Date			Tue 1 Dec 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 04Jan99 void	DPlay::DeselectChatPlayer()
//DeadCode AMM 04Jan99 {
//DeadCode AMM 04Jan99 	sendtowho=oldsendtowho;
//DeadCode AMM 04Jan99 }

void	DPlay::ResetAllocPacket()
{
	ULong n;

	for (n=0;n<MAXPLAYERS;n++)
	{
		AllocPacket[n]=0;
	}
}

void	DPlay::ResetCommsGame()
{
	ULong n;

	SimulateExitKey=FALSE;

// unassign all players

	if (GameType>TEAMPLAY)
	{
		for(n=0;n<MAXPLAYERS;n++)
		{
			H2H_Player[n].squadron=-1;
			H2H_Player[n].position=-1;
		}
		MMC.playersquadron=-1;
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UpdateMessages
//Author		Andy McMaster
//Date			Wed 9 Dec 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	DPlay::UpdateMessages()
{
//DeadCode AMM 12May99 	char RecPacket[MAXCOMMSPACKETSIZE];
	char* RecPacket;
	ULong	PlayRequestCount=0;;
	ULong from;
	ULong RecPacketLen;

#ifdef CTRACE
	FILE* fp=fopen("ctrace.txt","at");
	fprintf(fp,"In UpdateMessages\n");
#endif

	if (!SendMyMessages(false))
	{
#ifdef CTRACE
		fprintf(fp,"Failed to send\n\n");
		fclose(fp);
#endif
		return false;
	}
/*
#ifdef CTRACE
	fprintf(fp,"sent messages OK\n");
#endif

	ULong now=_Miles.GetSysTime();
	CommsTimeout time(now,CommsTimeoutLength);

	for (;;)
	{
		now=_Miles.GetSysTime();

// messages dont matter that much - its not fatal if they are not received 
// properly

		if (time.TimedOut(now))
		{
#ifdef CTRACE
			fprintf(fp,"timed out in get messages\n\n");
#endif
			return false;
		}
//DeadCode AMM 09Apr99 			_Error.SayAndQuit("Timed out");

		if (PlayRequestCount == (CurrPlayers - 1))
		{
#ifdef CTRACE
			fprintf(fp,"got all messages\n");
#endif
			break;
		}

//DeadCode AMM 12May99 		RecPacketLen = MAXCOMMSPACKETSIZE;

		ULong to=myDPlayID;
//DeadCode AMM 12May99 		if (ReceiveNextMessage (RecPacket, RecPacketLen,from))
		if (ReceiveNextMessage (RecPacket, RecPacketLen,from,to,DPRECEIVE_TOPLAYER))
		{
#ifdef CTRACE
			fprintf(fp,"got message from ");
#endif
			if (from==0)
			{
#ifdef CTRACE
				fprintf(fp,"system\n");
#endif
				ProcessSystemMessage(RecPacket,CPS_GAMESTARTUP);
			}
			else if (from!=aggID)
			{
				PUIPLAYERDATA pack = (PUIPLAYERDATA)RecPacket;

				if (pack->PacketID == PID_MESSAGES)
				{
					ReceiveMessages((UByte*)RecPacket,from);
					PlayRequestCount++;
#ifdef CTRACE
					fprintf(fp,"player - PID_MESSAGES\n");
					fprintf(fp,"playrequestcount=%d currplayers=%d\n",PlayRequestCount,CurrPlayers);
#endif
				}
				else
				{
#ifdef CTRACE
					fprintf(fp,"player - other message ID=%x\n",pack->PacketID);
#endif
					ProcessPlayerMessage(RecPacket,RecPacketLen,from,CPS_GAMESTARTUP);
				}
			}
		}
	}*/
#ifdef CTRACE
	fprintf(fp,"UpdateMessages TRUE\n\n");
	fclose(fp);
#endif

	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UpdateMissionConditions
//Author		Andy McMaster
//Date			Tue 5 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::UpdateMissionConditions()
{
	ULong RecPacketLen;
	ULong from;
//DeadCode AMM 12May99 	char RecPacket[MAXCOMMSPACKETSIZE];
	char* RecPacket;

// NEEDTIMEOUT
	if (Host)
	{
		if (!SendMissionConditions (false))
			return FALSE;
	}
	else
	{
// Receive Prefs Packet

		ULong now=_Miles.GetSysTime();

		CommsTimeout time(now,CommsTimeoutLength);

		for (;;)
		{
			now=_Miles.GetSysTime();

			if (time.TimedOut(now))
				_Error.SayAndQuit("Timed out (UMC)");

//DeadCode AMM 12May99 			RecPacketLen = MAXCOMMSPACKETSIZE;

			ULong to=myDPlayID;
//DeadCode AMM 12May99 			if (ReceiveNextMessage(RecPacket, RecPacketLen,from))
			if (ReceiveNextMessage(RecPacket, RecPacketLen,from,to,DPRECEIVE_TOPLAYER))
			{
				if (from==0)
				{
					ProcessSystemMessage(RecPacket,RecPacketLen);
				}
				else if (from!=aggID)
				{
					PUIPLAYERDATA pUIPlayerData = (PUIPLAYERDATA)RecPacket;

					if (pUIPlayerData->PacketID == PID_MISSIONCONDITIONS)
				   	{
						ProcessConditionsPacket(RecPacket);
						break;

					}
					else
					{
						ProcessPlayerMessage(RecPacket,RecPacketLen,from,CPS_GAMESTARTUP);
					}
				}
			}
		}
	}
	return TRUE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendMissionConditions
//Author		Andy McMaster
//Date			Tue 5 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::SendMissionConditions(bool request)
{
	CONDITIONSDATA 	cd;
	MISSIONCONDS	mc;

	if (PlayerCreated && Host)
	{
		cd.PacketID=PID_MISSIONCONDITIONS;

		mc.TempVar=MMC.Sky.TempVar;
		mc.Temp0=MMC.Sky.Temp0;
		mc.Press0=MMC.Sky.Press0;
		mc.Density0=MMC.Sky.Density0;
		mc.wind0=MMC.Sky.wind0;
		mc.dir0=MMC.Sky.dir0;				
		mc.windalt=MMC.Sky.windalt;			
		mc.diralt=MMC.Sky.diralt;				
		mc.Wind0=MMC.Sky.Wind0;				
		mc.WindAlt=MMC.Sky.WindAlt;			
		mc.WindAltHeight=MMC.Sky.WindAltHeight;		
		mc.MinDuration=MMC.Sky.MinDuration;		
		mc.MaxDuration=MMC.Sky.MaxDuration;		
		mc.MinMagnitude=MMC.Sky.MinMagnitude;		
		mc.MaxMagnitude=MMC.Sky.MaxMagnitude;		
		mc.Frequency=MMC.Sky.Frequency;		
		mc.ContrailBandCentre=MMC.Sky.ContrailBandCentre;
		mc.ContrailBandWidth=MMC.Sky.ContrailBandWidth;
		mc.Visibility=MMC.Sky.Visibility;			
		mc.Conditions=MMC.Sky.Conditions;			
		mc.CloudLayer=MMC.Sky.CloudLayer;			
		mc.MistInValley=MMC.Sky.MistInValley;

		if (sizeof(MISSIONCONDS)>512)
			_Error.SayAndQuit("Mission Conditions>512");

		memcpy(&cd.conds,&mc,sizeof(MISSIONCONDS));

//DeadCode AMM 23May99 		return(SendMessageToPlayers((char*)&cd,sizeof(CONDITIONSDATA)));
		if (request)
		{
			return (SendMessageToAll((char*)&cd,sizeof(CONDITIONSDATA)));
		}
		else
		{
			if (SendGMessageToPlayersTimeout((char*)&cd,sizeof(CONDITIONSDATA)))
				return TRUE;
		}
//DeadCode AMM 16Jun99 		if (SendGMessageToPlayersTimeout((char*)&cd,sizeof(CONDITIONSDATA)))
//DeadCode AMM 16Jun99 			return TRUE;
	}

	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ProcessConditionsPacket
//Author		Andy McMaster
//Date			Tue 5 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::ProcessConditionsPacket(char* message)
{
	LPCONDITIONSDATA 	cd;
	LPMISSIONCONDS	mc;

	cd=(LPCONDITIONSDATA)message;
	mc=(LPMISSIONCONDS)cd->conds;

	MMC.Sky.TempVar=mc->TempVar;
	MMC.Sky.Temp0=mc->Temp0;
	MMC.Sky.Press0=mc->Press0;
	MMC.Sky.Density0=mc->Density0;
	MMC.Sky.wind0=mc->wind0;
	MMC.Sky.dir0=mc->dir0;
	MMC.Sky.windalt=mc->windalt;
	MMC.Sky.diralt=mc->diralt;
	MMC.Sky.Wind0=mc->Wind0;
	MMC.Sky.WindAlt=mc->WindAlt;
	MMC.Sky.WindAltHeight=mc->WindAltHeight;	
	MMC.Sky.MinDuration=mc->MinDuration;
	MMC.Sky.MaxDuration=mc->MaxDuration ;
	MMC.Sky.MinMagnitude=mc->MinMagnitude;
	MMC.Sky.MaxMagnitude=mc->MaxMagnitude;
	MMC.Sky.Frequency=mc->Frequency;
	MMC.Sky.ContrailBandCentre=mc->ContrailBandCentre;
	MMC.Sky.ContrailBandWidth=mc->ContrailBandWidth;
	MMC.Sky.Visibility=mc->Visibility;
	MMC.Sky.Conditions=mc->Conditions;
	MMC.Sky.CloudLayer=mc->CloudLayer;
	MMC.Sky.MistInValley=mc->MistInValley;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DisplayPlayerJoiningMessage
//Author		Andy McMaster
//Date			Mon 11 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::DisplayPlayerJoiningMessage(ULong slot)
{
	AirStrucPtr i=Persons2::PlayerSeenAC;
	AirStrucPtr ac=*Persons2::ConvertPtrUID((UniqueID)AllocPacket[slot]);

//DeadCode AMM 16Jun99 	_Radio.TriggerMsg(MESSAGE_STRUC(PHRASE_JOINING,MSG_HIPRIORITY,i,i,i));

	DisplayPlayerMessage(ac,ac,ST_PLAYERJOINING,0);
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DisplayResyncingMessage
//Author		Andy McMaster
//Date			Mon 11 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::DisplayResyncingMessage()
{
	AirStrucPtr i=Persons2::PlayerSeenAC;

//	_Radio.TriggerMsg(MESSAGE_STRUC(PHRASE_RESYNCHING,MSG_HIPRIORITY,i,i,i));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DisplayResyncOKMessage
//Author		Andy McMaster
//Date			Mon 11 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::DisplayResyncOKMessage()
{
//DeadCode DAW 30Sep99 	AirStrucPtr i=Persons2::PlayerSeenAC;
//DeadCode DAW 30Sep99 
//DeadCode DAW 30Sep99 	if (!network)
//DeadCode DAW 30Sep99 		_Radio.TriggerMsg(MESSAGE_STRUC(PHRASE_RESYNCHSUC,MSG_HIPRIORITY,i,i,i));
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendSavegame
//Author		Andy McMaster
//Date			Thu 14 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 12May99 void	DPlay::SendSaveGame(bool score)
bool	DPlay::SendSaveGame(bool score,bool startup)
{
// copy savegame file into as many packets as needed. Send a header packet saying how
// many packets to expect, and inital segment of save data. Subsequent packets have
// header saying which packet they are in the order (in case of out of order arrivals)

	COMMONDATA cd;
	char savedgamename[150];
	ULong	savesize,numpackets;
	HANDLE	savegame;

//	GetLastSaveName(savedgamename);

	strcpy(savedgamename,"dcomms.dat");

	GetCommsSavename(savedgamename);

	if (H2H_Player[mySlot].status!=CPS_3D)
		_Replay.SaveTempSaveGame("dcomms.dat",true);

	savegame=CreateFile(
		savedgamename,
		GENERIC_READ|GENERIC_WRITE,
		FILE_SHARE_READ|FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		NULL,
		NULL);

	if (savegame!=INVALID_HANDLE_VALUE)
	{
		savesize=GetFileSize(savegame,NULL);
		numpackets=savesize/500;
		if (savesize%500)
			numpackets++;

//DeadCode DAW 22Jun99 		if (score)
//DeadCode DAW 22Jun99 			cd.PacketID=PID_SAVEGAMESCORE;
//DeadCode DAW 22Jun99 		else
			cd.PacketID=PID_SAVEGAME;

		cd.PlayerID=numpackets;
		cd.Slot=savesize;

		if (startup)
		{
 			if (!SendMessageToAll((char*)&cd,sizeof(COMMONDATA)))
				return false;
		}
		else
		{
			if (!SendGMessageToPlayersTimeout((char*)&cd,sizeof(COMMONDATA)))
				return false;
		}

		ULong	index=0;
		SAVEGAMEPACKET sgp;
		ULong	readsize;
		ULong	numread;

		while (numpackets--)
		{
			sgp.PacketID=PID_SAVEGAMEBINARY;
			sgp.index=index++;

			if (numpackets)
				readsize=500;
			else
				readsize=savesize%500;

			sgp.size=readsize;

			ReadFile(
				savegame,
				&sgp.data,
				readsize,
				&numread,
				NULL);

//DeadCode AMM 12May99 			SendMessageToAll((char*)&sgp,sizeof(SAVEGAMEPACKET));
			if (startup)
			{
 				if (!SendMessageToAll((char*)&sgp,sizeof(SAVEGAMEPACKET)))
					return false;
			}
			else
			{
				if (!SendGMessageToPlayersTimeout((char*)&sgp,sizeof(SAVEGAMEPACKET)))
					return false;
			}
		}
	}

	return true;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ReceiveSavegame
//Author		Andy McMaster
//Date			Thu 14 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	DPlay::ReceiveSaveGame(bool startup,ULong num,ULong size)
{
//DeadCode AMM 12May99 	char RecPacket [MAXCOMMSPACKETSIZE];
	char* RecPacket;
	ULong RecPacketLen=0,from;
	ULong now=_Miles.GetSysTime();
	ULong rec=0;
	UByte*	save=new UByte[size];

	CommsTimeout time(now,(CommsTimeoutLength*2));

	while (rec!=num)
	{
		now=_Miles.GetSysTime();

		if (time.TimedOut(now))
		{
			delete [] save;
			return false;
		}

//DeadCode AMM 12May99 		RecPacketLen = MAXCOMMSPACKETSIZE;

		ULong to=myDPlayID;
		if (ReceiveNextMessage (RecPacket, RecPacketLen,from,to,DPRECEIVE_TOPLAYER))
		{
			if (startup)
			{
// if we are getting info about game initally dont bother with any other messages

				if (from!=0) // && RecPacketLen!=sizeof(AGGSENDPACKET))
				{
					if(((PCOMMONDATA)RecPacket)->PacketID == PID_SAVEGAMEBINARY)
					{
						rec++;
						UpdateSaveGame(save,RecPacket);
					}
				}
			}
			else
			{
				if (from==0)
				{
					ProcessSystemMessage(RecPacket,CPS_GAMESTARTUP);
				}
				else if (from!=aggID)
				{
					if(((PCOMMONDATA)RecPacket)->PacketID == PID_SAVEGAMEBINARY)
					{
						rec++;
						UpdateSaveGame(save,RecPacket);
					}
					else
					{
						ProcessPlayerMessage(RecPacket,RecPacketLen,from,CPS_GAMESTARTUP);
					}
				}
			}
		}
	}

	bool retval=SaveDummyCommsSaveGame(save,size);

	if (retval)
	{
//		if (H2H_Player[mySlot].status==CPS_MAP)
//			Persons4::ShutDownMapWorld();

		retval=LoadDummySavegame("dcomms.dat");

		if (H2H_Player[mySlot].status==CPS_FRAG)	//AMM 07/06/99
			FragChanged=true;					//AMM 07/06/99

//		if (H2H_Player[mySlot].status==CPS_MAP)
//			Persons4::StartUpMapWorld();

	}

	delete [] save;
	return retval;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UpdateSaveGame
//Author		Andy McMaster
//Date			Mon 18 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::UpdateSaveGame(UByte* savegamedata,char* pack)
{
	LPSAVEGAMEPACKET sgp;
	UByteP temp=savegamedata;

	sgp=(LPSAVEGAMEPACKET)pack;

	temp+=((sgp->index)*500);

	memcpy(temp,sgp->data,sgp->size);

//	FILE* fp=fopen("savedat.txt","at");
//	fprintf(fp,"index=%d size=%d\n",sgp->index,sgp->size);
//	fclose(fp);
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SaveDummyCommsSaveGame
//Author		Andy McMaster
//Date			Mon 18 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	DPlay::SaveDummyCommsSaveGame(UByte* data,ULong size)
{
	char	dummyname[150];
	HANDLE	dummyfile;
	ULong temp;
	bool	retval=false;

	strcpy(dummyname,"dcomms.dat");

	GetCommsSavename(dummyname);

	dummyfile=CreateFile(
		dummyname,
		GENERIC_WRITE|GENERIC_WRITE,
		FILE_SHARE_READ|FILE_SHARE_WRITE,
		NULL,
		CREATE_ALWAYS,
		NULL,
		NULL);

	if (dummyfile!=INVALID_HANDLE_VALUE)
	{
		WriteFile(
			dummyfile,
			data,
			size,
			&temp,
			NULL);

		retval=true;
	}

	CloseHandle(dummyfile);

	return retval;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ReceiveStartupSaveGame
//Author		Andy McMaster
//Date			Mon 18 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	DPlay::ReceiveStartupSaveGame(bool realstartup)
{
//DeadCode AMM 12May99 	char packet [MAXCOMMSPACKETSIZE];
	char* packet;
	ULong packlen,from;
	ULong now=_Miles.GetSysTime();
	bool	gotOK=false;

	CommsTimeout time(now,(CommsTimeoutLength*2));

	while (!gotOK)
	{
		now=_Miles.GetSysTime();

		if (time.TimedOut(now))
			return false;

//DeadCode AMM 12May99 		packlen=MAXCOMMSPACKETSIZE;

		ULong to;
		ULong flags;
		if (realstartup)
		{
			to=0;
			flags=0;
		}
		else
		{
			to=myDPlayID;
			flags=DPRECEIVE_TOPLAYER;
		}

//DeadCode AMM 12May99 		if (ReceiveNextMessage(packet,packlen,from))
		if (ReceiveNextMessage(packet,packlen,from,to,flags))
		{
			if (realstartup)
			{
				if (((PCOMMONDATA)packet)->PacketID==PID_SAVEGAME) // && packlen!=sizeof(AGGSENDPACKET))
				{
 					if (ReceiveSaveGame(true,((PCOMMONDATA)packet)->PlayerID,((PCOMMONDATA)packet)->Slot))
						gotOK=true;
				}
			}
			else
			{
				if (from==0)
				{
					ProcessSystemMessage(packet,CPS_GAMESTARTUP);
				}
				else if (from!=aggID)
				{
					if (((PCOMMONDATA)packet)->PacketID==PID_SAVEGAME)
					{
 						if (ReceiveSaveGame(true,((PCOMMONDATA)packet)->PlayerID,((PCOMMONDATA)packet)->Slot))
							gotOK=true;
					}
					else
					{
						ProcessPlayerMessage(packet,packlen,from,CPS_GAMESTARTUP);
					}
				}
			}
		}
	}

	return true;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		JoinComms
//Author		Andy McMaster
//Date			Wed 20 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::JoinComms()
{
	_DPlay.UIPlayerType = PLAYER_GUEST;

// need a temp name to be able to create a player with

	strcpy(_DPlay.PlayerName,"temp name");

// need to get game details before going to locker room so that info can be filled
// in correctly....

	if (_DPlay.UINewPlayer(_DPlay.PlayerName,_DPlay.SessionName))
	{
// null temp player name

		strcpy (_DPlay.PlayerName,"");

		if (_DPlay.GetGameDetails())
		{
			return TRUE;
		}
		CommsMessage(IDS_HOSTBUSY);
	}

	SessionName[0]='/0';									//AMM 01Jul99
	strcpy(_DPlay.PlayerName,"");

	_DPlay.lpDP4->DestroyPlayer(_DPlay.myDPlayID);
	_DPlay.lpDP4->Close();

	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		FindGoodSession
//Author		Andy McMaster
//Date			Wed 20 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::FindGoodSession()
{
	ULong now=_Miles.GetSysTime();
	CommsTimeout	time(now,CommsTimeoutLength);

	while (!time.TimedOut(_Miles.GetSysTime()))
	{
		_DPlay.UIGetSessionListUpdate();

		if (_DPlay.SessionList)
		{
			strncpy(_DPlay.SessionName,_DPlay.SessionList->sname,59);
			_DPlay.SessionName[59]=NULL;

			return TRUE;
		}
	}

	return FALSE;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		DeleteClaimBuffer
//Author		Andy McMaster
//Date			Fri 12 Mar 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::DeleteClaimBuffer()
{
	LPCLAIMER temp,temp1=HSB;

	while (temp1)
	{
		temp=temp1->next;
		delete temp1;
		temp1=temp;
	}
	HSB=NULL;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SetActivePilots
//Author		Andy McMaster
//Date			Thu 6 May 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 06May99 void	Campaign::ResetActivePilots()
//DeadCode AMM 06May99 {
//DeadCode AMM 06May99 	pilotstatus old;
//DeadCode AMM 06May99 
//DeadCode AMM 06May99 	for (int j = 0; j < PILOTS_PER_CAMPAIGN; j++)
//DeadCode AMM 06May99 	{
//DeadCode AMM 06May99 		old=Active_Pilots[j].status;
//DeadCode AMM 06May99 		Active_Pilots[j] = Active_Pilots_Init[j];
//DeadCode AMM 06May99 
//DeadCode AMM 06May99 		if (_DPlay.PlayerCreated && _DPlay.GameType>TEAMPLAY)
//DeadCode AMM 06May99 			Active_Pilots[j].status=old;
//DeadCode AMM 06May99 	}
//DeadCode AMM 06May99 }

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ApplyBackupPilots
//Author		Andy McMaster
//Date			Thu 6 May 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::ApplyBackupPilots()
{
	for (int n=0;n<PILOTS_PER_CAMPAIGN;n++)
	{
		MMC.Active_Pilots[n].status=(pilotstatus)BackupPilots[n];
	}
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendCampaignStruc
//Author		Andy McMaster
//Date			Thu 13 May 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	DPlay::SendCampaignStruc(bool startup)
{
	COMMONDATA cd;
	ULong numpackets;
	ULong campsize=sizeof(Campaign);

	numpackets=campsize/500;
	if (campsize%500)
		numpackets++;

	cd.PacketID=PID_CAMPAIGNSTRUC;
	cd.PlayerID=numpackets;

//DeadCode AMM 23May99 	SendMessageToAll((char*)&cd,sizeof(COMMONDATA));
	if (startup)
		SendMessageToAll((char*)&cd,sizeof(COMMONDATA));
	else
		SendGMessageToPlayersTimeout((char*)&cd,sizeof(COMMONDATA));

	ULong	index=0;
	ULong	copysize;
	ULong	numread;
	SAVEGAMEPACKET sgp;
	UByteP temp=(UByteP)&MMC;

	while (numpackets--)
	{
		sgp.PacketID=PID_CAMPAIGNSTRUCBINARY;
		sgp.index=index++;

		if (numpackets)
			copysize=500;
		else
			copysize=campsize%500;

		sgp.size=copysize;

		memcpy(&sgp.data,temp,copysize);
		temp+=copysize;

//DeadCode AMM 23May99 		if (!SendMessageToAll((char*)&sgp,sizeof(SAVEGAMEPACKET)))
		if (startup)
		{
			SendMessageToAll((char*)&sgp,sizeof(SAVEGAMEPACKET));
		}
		else
		{
			if (!SendGMessageToPlayersTimeout((char*)&sgp,sizeof(SAVEGAMEPACKET)))
				return false;
		}
//DeadCode AMM 26May99 		if (!SendGMessageToPlayersTimeout((char*)&sgp,sizeof(SAVEGAMEPACKET)))
//DeadCode AMM 26May99 			return false;
	}

	return true;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ReceiveCampaignStruc
//Author		Andy McMaster
//Date			Thu 13 May 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	 DPlay::ReceiveCampaignStruc()
{
	char* buffer;
	ULong buflen=0,from;
	ULong now=_Miles.GetSysTime();
	ULong rec=0,num;
	bool	got=false;

	CommsTimeout time(now,CommsTimeoutLength);

	while (!got)
	{
		now=_Miles.GetSysTime();

		if (time.TimedOut(now))
			return false;

		ULong to=myDPlayID;
		if (ReceiveNextMessage(buffer,buflen,from,to,DPRECEIVE_TOPLAYER))
		{
			if (from==0)
			{
				ProcessSystemMessage(buffer,buflen);
			}
			else if (from!=aggID)
			{
				if (((PCOMMONDATA)buffer)->PacketID==PID_CAMPAIGNSTRUC)
				{
					got=true;
					num=((PCOMMONDATA)buffer)->PlayerID;
				}
				else
				{
				 	ProcessPlayerMessage(buffer,buflen,from,CPS_GAMESTARTUP);
				}
			}
		}
	}

	now=_Miles.GetSysTime();
	time.Init(now,(CommsTimeoutLength*2));

	while (rec!=num)
	{
		now=_Miles.GetSysTime();

		if (time.TimedOut(now))
			return false;

		ULong to=myDPlayID;
		if (ReceiveNextMessage (buffer, buflen,from,to,DPRECEIVE_TOPLAYER))
		{
			if (from==0)
			{
				ProcessSystemMessage(buffer,buflen);
			}
			else if (from!=aggID)
			{
				LPSAVEGAMEPACKET sgp=(LPSAVEGAMEPACKET)buffer;

				if (sgp->PacketID==PID_CAMPAIGNSTRUCBINARY)
				{
					rec++;
					UByteP temp=(UByteP)&MMC;

					temp+=(500*(sgp->index));

					memcpy(temp,sgp->data,sgp->size);
				}
				else
				{
				 	ProcessPlayerMessage(buffer,buflen,from,CPS_GAMESTARTUP);
				}
			}
		}
	}

	return true;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		InitialFlagReset
//Author		Andy McMaster
//Date			Sun 6 Jun 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::InitialFlagReset()
{
// reset all flags etc before launching 3d as inital sync is on interrupt and can get
// called before flags are setup in SendInit and SendInit2 etc

	resyncbar=false;
	joiningplayerslot=-1;
	SuicideTime=0;
	AllowSuicide=TRUE;
	GameRunning=TRUE;
	deadplayers=0;
	accelselected=0;
	Implemented = TRUE;											//AMM 13May99
	firsttimein = TRUE; //AMM 18/05/99
	synched=FALSE; //AMM 18/05/99
	csync=false; //AMM 18/05/99
	ResyncPhase=FALSE; //AMM 18/05/99
	Initiator=FALSE; //AMM 18/05/99
	realfirsttimein=TRUE; //AMM 18/05/99
	resyncsgot=0; //AMM 18/05/99
	SimulateExitKey=FALSE; //AMM 18/05/99
	InitSyncData(true); //AMM 18/05/99
	FrameCount = 0; //AMM 18/05/99
	ResetSync=true; //AMM 18/05/99
	beginsyncflag=false;
	resetreceivesync=false;
	PlayerSync=false;
	HostQuit=false;
	resurrectend=false;

	BFieldToProcess=0;
	_Replay.DeleteFileAndGlobRefList(_Replay.bfgrlist);
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		SendBackupRandomList
//Author		Andy McMaster
//Date			Fri 18 Jun 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SendBackupRandomList(bool request)
{
	ULong n,packsize=sizeof(ULong) //PID
					+(RNDPACKETSIZE*sizeof(UWord));

	UByteP pack=new UByte[packsize];
	UByteP temp=pack;

	*(ULong*)temp=PID_RANDOMLIST;
	temp+=sizeof(ULong);

	for (n=0;n<(RNDPACKETSIZE);n++)
	{
		*(UWord*)temp=_Replay.BackupRndPacket[n];
		temp+=sizeof(UWord);
	}

	if (request)
	{
		SendMessageToPlayers((char*)pack,packsize);
	}
	else
	{
		SendGMessageToPlayers((char*)pack,packsize);
	}

// OK process the list myself now so that all players are same

	ProcessRandomList((char*)pack);

	delete [] pack;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		ProcessRandomList
//Author		Andy McMaster
//Date			Fri 18 Jun 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::ProcessRandomList(char* packet)
{
	UWord RndPacket [RNDPACKETSIZE];
	ULong n;

	packet+=sizeof(ULong); //skip PID

	for (n=0; n<RNDPACKETSIZE; n++)
	{
		RndPacket[n] = *(UWord*)packet;
		packet+=sizeof(UWord);
	}

	for (n=0; n<(RNDPACKETSIZE - 2); n++)
		Math_Lib.SetRndLookUp(n,RndPacket[n]);

	Math_Lib.Setbval(RndPacket[(RNDPACKETSIZE - 2)]);
	Math_Lib.Setcval(RndPacket[(RNDPACKETSIZE - 1)]);
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		AddChatMessageToBuffer
//Author		Andy McMaster
//Date			Wed 22 Sep 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::AddChatMessageToBuffer(const char* name, const char* chat)
{
	strcpy(ChatBuffer.GetNext()->name,name);
	strcpy(ChatBuffer.GetNext()->chat,chat);

	ChatBuffer.AddEntryAndUpdateNext();

	if (ChatBuffer.GetNext()==ChatBuffer.GetCurr())
		ChatBuffer.UpdateCurr();
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		UpdateChatBox
//Author		Andy McMaster
//Date			Wed 22 Sep 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::UpdateChatBox()
{
	ChatBuffer.SetTempCurr();

	while (ChatBuffer.GetTemp()!=ChatBuffer.GetNext())
	{
		if (H2H_Player[mySlot].status==CPS_READYROOM)
			DisplayReadyDialogue(ChatBuffer.GetTemp()->name,ChatBuffer.GetTemp()->chat);
#ifndef	MIG_DEMO_VER
		else if (H2H_Player[mySlot].status==CPS_FRAG)
			DisplayFragDialogue(ChatBuffer.GetTemp()->name,ChatBuffer.GetTemp()->chat);
#endif

		ChatBuffer.UpdateTemp();
	}
}

Bool DPlay::LobbyConnect()
{
	Bool res=TRUE;;
	
	if (lpDPL->ConnectEx(0,IID_IDirectPlay4A,(void**)&_DPlay.lpDP4,NULL)!=DP_OK)
		res=FALSE;

	if (!res)
	{
		lpDPL->Release();
		lpDPL=NULL;
		lpDP4=NULL;
	}
	else
	{
		res=_DPlay.SetUpPlayer();
	}

	return res;
}

void	DPlay::Process_PM_CSStruc(char* pack)
{
	ULong size,numparts;
	char* Buffer;
	ULong	BufferLen=0;
	ULong From,n;
	ULong rec=0;

	if (!Host)
	{
// mission has changed, unassign all player slots

		for (n=0;n<MAXPLAYERS;n++)
		{
			H2H_Player[n].squadron=-1;
			H2H_Player[n].position=-1;
		}

		MMC.playersquadron=-1;
		MMC.playeracnum=-1;

		if (H2H_Player[mySlot].status==CPS_FRAG)
			FragChanged=true;

// want to update mission name

		DisplayInfo=TRUE;
	}

	size=((PCOMMONDATA)pack)->Slot;
	numparts=((PCOMMONDATA)pack)->PlayerID;

// get parts

	UByte*	struc=new UByte[size];

	ULong now=timeGetTime();
	CommsTimeout time(now,(CommsTimeoutLength*2));

	while (rec!=numparts)
	{
		now=timeGetTime();

		if (time.TimedOut(now))
		{
			delete [] struc;
			return;
		}

		ULong to=0;
		if (ReceiveNextMessage (Buffer, BufferLen,From,to,0))
		{
// if we are getting info about game initally dont bother with any other messages

			if (From!=0 && BufferLen!=sizeof(AGGSENDPACKET))
			{
				if(((PCOMMONDATA)Buffer)->PacketID == PID_CSSTRUCBINARY)
				{
					LPCSSTRUCPART csp=(LPCSSTRUCPART)Buffer;

					GameIndex=csp->newmissionnum;

					UByteP temp=struc;

					temp+=(csp->index)*500;

					CopyMemory(temp,csp->data,csp->size);

					rec++;
				}
			}
		}
	}

	UpdateCSQuick((UByte*)struc,GameIndex);

	delete [] struc;
}

//컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴컴
//Procedure		CheckPacketSizes
//Author		Andy McMaster
//Date			Wed 28 Oct 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::CheckPacketSizes()
{
	ULong size=sizeof(ACPACKET);

	if (size==sizeof(COMMONDATA))
		_Error.SayAndQuit("COMMONDATA same size as ACPACKET");

	if (size==sizeof(UILOOKUPTABLE))
		_Error.SayAndQuit("UILOOKUPTABLE same size as ACPACKET");

	if (size==sizeof(INITINFO))
		_Error.SayAndQuit("INITINFO same size as ACPACKET");

	if (size==sizeof(GAMEAVAILABLEPACKET))
		_Error.SayAndQuit("GAMEAVAILABLEPACKET same size as ACPACKET");

	if (size==sizeof(PASSWORDPACK))
		_Error.SayAndQuit("PASSWORDPACK same size as ACPACKET");

	if (size==sizeof(GAMEDETAILS))
		_Error.SayAndQuit("GAMEDETAILS same size as ACPACKET");

	if (size==sizeof(SLOTPOSPACK))
		_Error.SayAndQuit("SLOTPOSPACK same size as ACPACKET");

	if (size==sizeof(UIPREFSDATA))
		_Error.SayAndQuit("UIPREFSDATA same size as ACPACKET");

	if (size==sizeof(CONTROLPACKET))
		_Error.SayAndQuit("CONTROLPACKET same size as ACPACKET");

	if (size==sizeof(AGGREPLYPACKET))
		_Error.SayAndQuit("AGGREPLAYPACKET same size as ACPACKET");

	if (size==sizeof(ACSTATEPACKET))
		_Error.SayAndQuit("ACSTATEPACKET same size as ACPACKET");

	if (size==sizeof(ALLOCREQUEST))
		_Error.SayAndQuit("ALLOCREQUEST same size as ACPACKET");

}
